# Story 1.5: Update run_search for CLI Compatibility

## Status
Draft

## Story
**As a** CLI user,
**I want** the `run_search()` function to use the new internal search function,
**so that** CLI behavior remains identical while benefiting from the refactored code.

## Acceptance Criteria

1. - [ ] Output is byte-for-byte identical for all existing test cases
2. - [ ] Shorthand flags (`--no-headers`, `--find`) still work
3. - [ ] Output formatting options unchanged
4. - [ ] Color output works correctly
5. - [ ] File output (`--output`) works correctly
6. - [ ] Unit tests for `run_search` pass
7. - [ ] Integration tests for CLI pass
8. - [ ] Format-specific tests (default, cat, find, json) pass
9. - [ ] Search time within 5% of original
10. - [ ] Memory usage comparable

## Tasks / Subtasks

- [ ] Update `run_search` in `src/commands/search.rs` (AC: 1, 2, 3, 4, 5)
  - [ ] Handle shorthand flags (--no-headers, --find)
  - [ ] Convert CLI args to SearchOptions
  - [ ] Call perform_search_internal
  - [ ] Format and output results (unchanged from original)
- [ ] Test CLI behavior preservation (AC: 6, 7, 8)
  - [ ] Run full test suite
  - [ ] Compare output for key test cases
- [ ] Verify performance (AC: 9, 10)
  - [ ] Benchmark search time
  - [ ] Monitor memory usage

## Dev Notes

### Location
- Primary file: `src/commands/search.rs`
- [Source: docs/epics/library-api-epic.md - Story 5]

### Complete Implementation

```rust
/// CLI entry point for search command
///
/// External behavior remains completely unchanged. Internally uses
/// the new perform_search_internal() function.
pub fn run_search(mut args: SearchArgs) -> Result<()> {
    // Handle shorthand flags (unchanged from original)
    if args.no_headers {
        args.format = Format::Cat;
    }
    if args.find {
        args.format = Format::Find;
    }

    // Convert CLI args to library options
    let options = SearchOptions {
        root: args.root.clone(),
        presets: args.preset.clone(),
        no_ignore: args.no_ignore,
        hidden: args.hidden,
        max_depth: args.max_depth,
        sql_dialect: args.dialect.map(Into::into),
    };

    let query = args.query.as_deref().unwrap_or("");

    // Use new internal search function
    let matching_files = perform_search_internal(query, &options)?;

    // Format and output (unchanged from original)
    let output_writer: Box<dyn Write> = match &args.output {
        Some(path) => Box::new(File::create(path)?),
        None => Box::new(std::io::stdout()),
    };

    formatter::print_output(
        output_writer,
        &matching_files,
        &args.format,
        args.color,
        args.line_numbers,
        args.context,
    )?;

    Ok(())
}
```

### Why clone args fields?
`SearchOptions` takes ownership while `SearchArgs` may be borrowed. Cloning is cheap for:
- `PathBuf` - typically small strings
- `Vec<String>` - usually 0-2 presets
- Primitives - Copy types

The alternative (making `SearchOptions` use references) would require lifetime parameters, complicating the public API.

### Testing Approach
```bash
# Run all existing tests
cargo test

# Run CLI integration tests specifically
cargo test --test cli_tests

# Compare output manually for key test cases
rdump search "ext:rs" --format json > before.json
# (after change)
rdump search "ext:rs" --format json > after.json
diff before.json after.json
```

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Results must be sorted - deterministic output
- Never use `unwrap()` on user data

### Testing

**Test Location:** `tests/cli.rs` and existing test files

**Test Cases:**
- All existing CLI tests must pass unchanged
- Output format tests (json, markdown, cat, find)
- Shorthand flag behavior
- Performance regression testing
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use tempfile::TempDir;

    #[test]
    fn test_run_search_basic() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Default,
            output: None,
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: false,
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());
    }

    #[test]
    fn test_run_search_no_headers_flag() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Default,
            output: None,
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: true, // Should convert to Cat format
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());
    }

    #[test]
    fn test_run_search_find_flag() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Default,
            output: None,
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: false,
            find: true, // Should convert to Find format
        };

        let result = run_search(args);
        assert!(result.is_ok());
    }

    #[test]
    fn test_run_search_file_output() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let output_file = temp_dir.path().join("output.txt");

        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Find,
            output: Some(output_file.clone()),
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: false,
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());
        assert!(output_file.exists());
    }

    #[test]
    fn test_run_search_json_format() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let output_file = temp_dir.path().join("output.json");

        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Json,
            output: Some(output_file.clone()),
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: false,
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());

        // Verify valid JSON output
        let content = std::fs::read_to_string(&output_file).unwrap();
        let parsed: serde_json::Value = serde_json::from_str(&content).unwrap();
        assert!(parsed.is_array() || parsed.is_object());
    }

    #[test]
    fn test_run_search_empty_query() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "fn main() {}").unwrap();

        let args = SearchArgs {
            query: None, // Empty query
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Find,
            output: None,
            color: false,
            line_numbers: false,
            context: 0,
            no_headers: false,
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());
    }

    #[test]
    fn test_run_search_with_context() {
        let temp_dir = TempDir::new().unwrap();
        let test_file = temp_dir.path().join("test.rs");
        std::fs::write(&test_file, "// comment\nfn main() {\n    println!(\"hi\");\n}").unwrap();

        let args = SearchArgs {
            query: Some("fn".to_string()),
            root: temp_dir.path().to_path_buf(),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            format: Format::Default,
            output: None,
            color: false,
            line_numbers: true,
            context: 2, // Show 2 lines of context
            no_headers: false,
            find: false,
        };

        let result = run_search(args);
        assert!(result.is_ok());
    }
}
```

#### Integration Test Commands

Run these commands to verify byte-for-byte compatibility:

```bash
# Before refactoring - save baseline outputs
rdump search "ext:rs" --format json > /tmp/baseline_json.txt
rdump search "ext:rs" --format find > /tmp/baseline_find.txt
rdump search "fn" --format cat > /tmp/baseline_cat.txt

# After refactoring - compare outputs
rdump search "ext:rs" --format json > /tmp/new_json.txt
rdump search "ext:rs" --format find > /tmp/new_find.txt
rdump search "fn" --format cat > /tmp/new_cat.txt

diff /tmp/baseline_json.txt /tmp/new_json.txt
diff /tmp/baseline_find.txt /tmp/new_find.txt
diff /tmp/baseline_cat.txt /tmp/new_cat.txt
```

#### Performance Benchmarking

```bash
# Run search benchmark
hyperfine --warmup 3 \
  'rdump search "ext:rs AND fn" --format find' \
  --export-json bench_results.json

# Memory profiling (macOS)
/usr/bin/time -l rdump search "ext:rs AND fn" --format find

# Compare before/after timing
# Target: within 5% of baseline
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
