# Story 1.10: Create search Convenience Function

## Status
Draft

## Story
**As a** library user,
**I want** a convenience wrapper that collects all results into a Vec,
**so that** I can easily get all results for small result sets without manual iteration.

## Acceptance Criteria

1. - [ ] Public function in `rdump` crate root
2. - [ ] Takes `&str` query and owned `SearchOptions`
3. - [ ] Returns `Result<Vec<SearchResult>>`
4. - [ ] Collects all results, including errors
5. - [ ] First error encountered causes `Err` return
6. - [ ] Empty result set returns `Ok(vec![])`
7. - [ ] Rustdoc with description and example
8. - [ ] Performance warning for large result sets
9. - [ ] Points users to `search_iter` for large codebases

## Tasks / Subtasks

- [ ] Create `search` function in `src/lib.rs` (AC: 1, 2, 3)
  - [ ] Accept `query: &str` and `options: SearchOptions`
  - [ ] Call `search_iter`
  - [ ] Collect results into Vec
- [ ] Implement collection behavior (AC: 4, 5, 6)
  - [ ] Use `.collect()` on Result iterator
  - [ ] Short-circuit on first error
- [ ] Add rustdoc documentation (AC: 7, 8, 9)
  - [ ] Usage example
  - [ ] Performance note
  - [ ] Reference to search_iter
- [ ] Write tests

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 10]

### Complete Implementation

```rust
/// Search for files matching a query (convenience wrapper)
///
/// Collects all results into a Vec. Use [`search_iter`] for large codebases
/// to avoid loading all content into memory at once.
///
/// # Arguments
///
/// * `query` - An RQL query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// A vector of all matching files with their content loaded.
///
/// # Example
///
/// ```rust
/// use rdump::{search, SearchOptions};
/// use std::path::PathBuf;
///
/// let results = search(
///     "ext:rs & func:main",
///     SearchOptions {
///         root: PathBuf::from("./src"),
///         ..Default::default()
///     }
/// )?;
///
/// println!("Found {} files", results.len());
///
/// for result in &results {
///     if result.is_whole_file_match() {
///         println!("  {} (whole file)", result.path.display());
///     } else {
///         println!("  {} ({} hunks)",
///             result.path.display(),
///             result.matches.len()
///         );
///     }
/// }
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// # Performance Note
///
/// This loads all matching file contents into memory. For repositories
/// with many matches, consider using [`search_iter`] instead:
///
/// ```rust
/// // Better for large result sets
/// for result in search_iter("ext:rs", options)? {
///     process(result?);
/// }
/// ```
pub fn search(query: &str, options: SearchOptions) -> Result<Vec<SearchResult>> {
    search_iter(query, options)?.collect()
}
```

### Why Does .collect() Work?
`SearchResultIterator` yields `Result<SearchResult>`, and `collect()` on an iterator of `Result<T, E>` into `Result<Vec<T>, E>` is a special impl that short-circuits on the first error. This is usually what users want.

### Usage Patterns

#### Basic Search
```rust
use rdump::{search, SearchOptions};
use std::path::PathBuf;

let results = search(
    "ext:rs & func:main",
    SearchOptions {
        root: PathBuf::from("./src"),
        ..Default::default()
    }
)?;

println!("Found {} files", results.len());
```

#### Iterating Results
```rust
for result in &results {
    if result.is_whole_file_match() {
        println!("  {} (whole file)", result.path.display());
    } else {
        println!("  {} ({} hunks)", result.path.display(), result.matches.len());
    }
}
```

#### Processing All Matches
```rust
let all_functions: Vec<String> = search("func:", SearchOptions::default())?
    .iter()
    .flat_map(|r| r.matches.iter())
    .map(|m| m.text.clone())
    .collect();
```

#### Getting Total Match Count
```rust
let total_matches: usize = search("class:", SearchOptions::default())?
    .iter()
    .map(|r| r.matches.len())
    .sum();
```

### Complete Test Cases

**Test Location:** `tests/library_api.rs`

```rust
use rdump::{search, SearchOptions};
use std::fs;
use std::path::PathBuf;
use tempfile::tempdir;

#[test]
fn test_search_basic_extension() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].path.to_string_lossy().ends_with(".rs"));
}

#[test]
fn test_search_no_results() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.txt");
    fs::write(&file, "some text").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 0);
}

#[test]
fn test_search_nonexistent_root() {
    let result = search("ext:rs", SearchOptions {
        root: PathBuf::from("/nonexistent/path"),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_invalid_query() {
    let dir = tempdir().unwrap();

    let result = search("invalid::: syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_multiple_files() {
    let dir = tempdir().unwrap();

    for i in 0..5 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 5);
}

#[test]
fn test_search_with_func_predicate() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn my_func() {\n    println!(\"hello\");\n}").unwrap();

    let results = search("func:my_func", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(!results[0].matches.is_empty());
}

#[test]
fn test_search_empty_result_vec() {
    let dir = tempdir().unwrap();
    // Create empty directory

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert!(results.is_empty());
}

#[test]
fn test_search_first_error_short_circuits() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    // Create iterator, then delete file
    let options = SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    };

    // First get the iterator
    let iter = rdump::search_iter("ext:rs", options.clone()).unwrap();

    // Delete file
    fs::remove_file(&file).unwrap();

    // Now collect - should get error
    let result: Result<Vec<_>, _> = iter.collect();
    assert!(result.is_err());
}

#[test]
fn test_search_whole_file_match() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert!(results[0].is_whole_file_match());
}

#[test]
fn test_search_with_matches() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert!(!results[0].is_whole_file_match());
    assert!(!results[0].matches.is_empty());
}

#[test]
fn test_search_content_loaded() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    let content = "fn main() { println!(\"Hello, world!\"); }";
    fs::write(&file, content).unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results[0].content, content);
}
```

### Performance Considerations

**When to use `search()`:**
- Small to medium result sets (< 1000 files)
- When you need random access to all results
- Simple scripts and one-off queries

**When to use `search_iter()`:**
- Large codebases with many matches
- When processing results sequentially
- When you need early termination
- Memory-constrained environments

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
