# Story 1.6: Create SearchResultIterator Struct

## Status
Done

## Story
**As a** library user,
**I want** a streaming iterator that yields `SearchResult` items lazily,
**so that** I can process large result sets memory-efficiently without loading all files upfront.

## Acceptance Criteria

1. - [x] Implements `Iterator<Item = Result<SearchResult>>`
2. - [x] Implements `ExactSizeIterator` (knows total count)
3. - [x] Implements `FusedIterator` (returns None forever after exhausted)
4. - [x] `size_hint()` returns accurate `(remaining, Some(remaining))`
5. - [x] File content loaded only when `next()` is called
6. - [x] Only one file's content in memory at a time
7. - [x] Early termination (`.take(n)`) prevents unnecessary file reads
8. - [x] File read errors returned as `Err`, not panics
9. - [x] Error includes file path for context
10. - [x] Iterator continues after error (can skip failed files)
11. - [x] `remaining()` returns count of unprocessed results

## Tasks / Subtasks

- [x] Create `SearchResultIterator` struct in `src/lib.rs` (AC: 1)
  - [x] Store `inner: std::vec::IntoIter<(PathBuf, Vec<Range>)>`
- [x] Implement `new()` constructor
- [x] Implement `Iterator` trait (AC: 1, 5, 8, 9, 10)
  - [x] Load file content lazily in `next()`
  - [x] Handle file read errors gracefully
  - [x] Convert ranges to matches
- [x] Implement `size_hint()` (AC: 4)
- [x] Implement `ExactSizeIterator` (AC: 2)
- [x] Implement `FusedIterator` (AC: 3)
- [x] Implement `remaining()` helper method (AC: 11)
- [x] Write tests for lazy loading behavior (AC: 5, 6, 7)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `SearchResultIterator` (Iterator + ExactSizeIterator + FusedIterator) with lazy content loading, error propagation including path, and `remaining()`/accurate `size_hint()`.
  - Added `ranges_to_matches` helper to convert tree-sitter ranges to `Match` with bounds checks.
  - Added unit tests covering conversion, iterator size_hint/remaining, error path inclusion, and early termination.
- File List:
  - rdump/src/lib.rs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 1.0 | Implemented SearchResultIterator with lazy loading, conversions, and tests | Dev Agent |

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 6]

### Complete Implementation

```rust
/// Iterator over search results
///
/// Yields `SearchResult` items lazily, loading file content only when
/// each item is consumed. This provides memory efficiency for large
/// result sets.
///
/// # Example
///
/// ```rust
/// let iter = search_iter("ext:rs", SearchOptions::default())?;
///
/// // Process results one at a time
/// for result in iter {
///     let result = result?;
///     println!("{}", result.path.display());
/// }
///
/// // Or take just a few
/// let first_five: Vec<_> = search_iter("ext:rs", options)?
///     .take(5)
///     .collect::<Result<Vec<_>, _>>()?;
/// ```
pub struct SearchResultIterator {
    /// Raw results from perform_search_internal
    inner: std::vec::IntoIter<(PathBuf, Vec<Range>)>,
}

impl SearchResultIterator {
    /// Create a new iterator from raw search results
    pub(crate) fn new(results: Vec<(PathBuf, Vec<Range>)>) -> Self {
        Self {
            inner: results.into_iter(),
        }
    }

    /// Get the number of remaining results
    pub fn remaining(&self) -> usize {
        self.inner.len()
    }
}

impl Iterator for SearchResultIterator {
    type Item = Result<SearchResult>;

    fn next(&mut self) -> Option<Self::Item> {
        let (path, ranges) = self.inner.next()?;

        // Load file content lazily (only when this result is consumed)
        let content = match std::fs::read_to_string(&path) {
            Ok(c) => c,
            Err(e) => {
                return Some(Err(anyhow::anyhow!(
                    "Failed to read {}: {}",
                    path.display(),
                    e
                )));
            }
        };

        // Convert tree-sitter ranges to Match structs
        let matches = ranges_to_matches(&content, &ranges);

        Some(Ok(SearchResult {
            path,
            matches,
            content,
        }))
    }

    fn size_hint(&self) -> (usize, Option<usize>) {
        self.inner.size_hint()
    }
}

impl ExactSizeIterator for SearchResultIterator {}

// Optionally implement FusedIterator for efficiency
impl std::iter::FusedIterator for SearchResultIterator {}
```

### Helper Function: ranges_to_matches

This helper converts tree-sitter ranges to Match structs (implemented in Story 7):

```rust
/// Convert tree-sitter Range to user-friendly Match structs
fn ranges_to_matches(content: &str, ranges: &[Range]) -> Vec<Match> {
    ranges
        .iter()
        .filter_map(|range| {
            // Safe bounds checking
            if range.start_byte > content.len() || range.end_byte > content.len() {
                return None;
            }

            let text = content
                .get(range.start_byte..range.end_byte)?
                .to_string();

            Some(Match {
                start_line: range.start_point.row + 1,  // 0 → 1 indexed
                end_line: range.end_point.row + 1,
                start_column: range.start_point.column,
                end_column: range.end_point.column,
                byte_range: range.start_byte..range.end_byte,
                text,
            })
        })
        .collect()
}
```

### Why Lazy Loading Matters
```rust
// Without lazy loading (bad for large results):
let results: Vec<SearchResult> = raw_results
    .into_iter()
    .map(|(path, ranges)| {
        let content = fs::read_to_string(&path)?;  // Loads ALL files upfront
        Ok(SearchResult { path, matches, content })
    })
    .collect()?;

// With lazy loading (memory efficient):
let iter = SearchResultIterator::new(raw_results);
for result in iter.take(10) {  // Only reads 10 files
    // ...
}
```

### Memory Comparison
| Scenario | Without Lazy | With Lazy |
|----------|-------------|-----------|
| 1000 files, take 5 | ~10 MB | ~50 KB |
| 10000 files, take 10 | ~100 MB | ~100 KB |

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Content must be valid UTF-8 - skip binary files
- Never use `unwrap()` on user data - always handle errors

### Testing

**Test Location:** `tests/library_api.rs`

**Test Cases:**
- Lazy loading verification (file read timing)
- Early termination with `.take()`
- Error handling for missing/unreadable files
- `size_hint()` accuracy
- `remaining()` decrements correctly
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use tempfile::TempDir;
    use std::sync::atomic::{AtomicUsize, Ordering};

    #[test]
    fn test_iterator_basic() {
        let temp_dir = TempDir::new().unwrap();
        let file1 = temp_dir.path().join("test1.rs");
        let file2 = temp_dir.path().join("test2.rs");
        std::fs::write(&file1, "fn main() {}").unwrap();
        std::fs::write(&file2, "fn test() {}").unwrap();

        let raw_results = vec![
            (file1.clone(), vec![]),
            (file2.clone(), vec![]),
        ];

        let iter = SearchResultIterator::new(raw_results);
        let results: Vec<_> = iter.collect();

        assert_eq!(results.len(), 2);
        assert!(results[0].is_ok());
        assert!(results[1].is_ok());
    }

    #[test]
    fn test_iterator_lazy_loading() {
        // This test verifies that files are only read when next() is called
        let temp_dir = TempDir::new().unwrap();
        let file1 = temp_dir.path().join("test1.rs");
        let file2 = temp_dir.path().join("test2.rs");
        std::fs::write(&file1, "fn main() {}").unwrap();
        std::fs::write(&file2, "fn test() {}").unwrap();

        let raw_results = vec![
            (file1.clone(), vec![]),
            (file2.clone(), vec![]),
        ];

        let mut iter = SearchResultIterator::new(raw_results);

        // Take only first result
        let first = iter.next();
        assert!(first.is_some());
        assert!(first.unwrap().is_ok());

        // Second file should not have been read yet
        // (We can't directly test this without mocking fs::read_to_string,
        // but the remaining() count should still be 1)
        assert_eq!(iter.remaining(), 1);
    }

    #[test]
    fn test_iterator_early_termination() {
        let temp_dir = TempDir::new().unwrap();
        for i in 0..100 {
            let file = temp_dir.path().join(format!("test{}.rs", i));
            std::fs::write(&file, format!("fn test{}() {{}}", i)).unwrap();
        }

        let raw_results: Vec<_> = (0..100)
            .map(|i| (temp_dir.path().join(format!("test{}.rs", i)), vec![]))
            .collect();

        let iter = SearchResultIterator::new(raw_results);

        // Take only 5 results
        let results: Vec<_> = iter.take(5).collect();

        // Should only have 5 results
        assert_eq!(results.len(), 5);
        for result in results {
            assert!(result.is_ok());
        }
    }

    #[test]
    fn test_iterator_error_handling() {
        let temp_dir = TempDir::new().unwrap();
        let file1 = temp_dir.path().join("test1.rs");
        std::fs::write(&file1, "fn main() {}").unwrap();

        // Non-existent file
        let nonexistent = temp_dir.path().join("nonexistent.rs");

        let raw_results = vec![
            (file1.clone(), vec![]),
            (nonexistent.clone(), vec![]),
        ];

        let mut iter = SearchResultIterator::new(raw_results);

        // First should succeed
        let first = iter.next();
        assert!(first.is_some());
        assert!(first.unwrap().is_ok());

        // Second should error (file not found)
        let second = iter.next();
        assert!(second.is_some());
        let err = second.unwrap();
        assert!(err.is_err());
        let error_msg = err.unwrap_err().to_string();
        assert!(error_msg.contains("nonexistent.rs"));
    }

    #[test]
    fn test_iterator_continues_after_error() {
        let temp_dir = TempDir::new().unwrap();
        let file1 = temp_dir.path().join("test1.rs");
        let file3 = temp_dir.path().join("test3.rs");
        std::fs::write(&file1, "fn main() {}").unwrap();
        std::fs::write(&file3, "fn test() {}").unwrap();

        // Non-existent file in the middle
        let nonexistent = temp_dir.path().join("nonexistent.rs");

        let raw_results = vec![
            (file1.clone(), vec![]),
            (nonexistent.clone(), vec![]),
            (file3.clone(), vec![]),
        ];

        let iter = SearchResultIterator::new(raw_results);
        let results: Vec<_> = iter.collect();

        assert_eq!(results.len(), 3);
        assert!(results[0].is_ok()); // First file OK
        assert!(results[1].is_err()); // Second file error
        assert!(results[2].is_ok()); // Third file OK (iterator continues)
    }

    #[test]
    fn test_size_hint_accuracy() {
        let temp_dir = TempDir::new().unwrap();
        for i in 0..10 {
            let file = temp_dir.path().join(format!("test{}.rs", i));
            std::fs::write(&file, "fn main() {}").unwrap();
        }

        let raw_results: Vec<_> = (0..10)
            .map(|i| (temp_dir.path().join(format!("test{}.rs", i)), vec![]))
            .collect();

        let mut iter = SearchResultIterator::new(raw_results);

        // Initial size_hint should be (10, Some(10))
        assert_eq!(iter.size_hint(), (10, Some(10)));

        // Consume 3 elements
        iter.next();
        iter.next();
        iter.next();

        // Size hint should now be (7, Some(7))
        assert_eq!(iter.size_hint(), (7, Some(7)));
    }

    #[test]
    fn test_remaining_decrements() {
        let temp_dir = TempDir::new().unwrap();
        for i in 0..5 {
            let file = temp_dir.path().join(format!("test{}.rs", i));
            std::fs::write(&file, "fn main() {}").unwrap();
        }

        let raw_results: Vec<_> = (0..5)
            .map(|i| (temp_dir.path().join(format!("test{}.rs", i)), vec![]))
            .collect();

        let mut iter = SearchResultIterator::new(raw_results);

        assert_eq!(iter.remaining(), 5);
        iter.next();
        assert_eq!(iter.remaining(), 4);
        iter.next();
        assert_eq!(iter.remaining(), 3);
        iter.next();
        assert_eq!(iter.remaining(), 2);
        iter.next();
        assert_eq!(iter.remaining(), 1);
        iter.next();
        assert_eq!(iter.remaining(), 0);
    }

    #[test]
    fn test_exact_size_iterator() {
        let temp_dir = TempDir::new().unwrap();
        let file = temp_dir.path().join("test.rs");
        std::fs::write(&file, "fn main() {}").unwrap();

        let raw_results = vec![(file.clone(), vec![])];
        let iter = SearchResultIterator::new(raw_results);

        // ExactSizeIterator provides len()
        assert_eq!(iter.len(), 1);
    }

    #[test]
    fn test_fused_iterator() {
        let temp_dir = TempDir::new().unwrap();
        let file = temp_dir.path().join("test.rs");
        std::fs::write(&file, "fn main() {}").unwrap();

        let raw_results = vec![(file.clone(), vec![])];
        let mut iter = SearchResultIterator::new(raw_results);

        // First call returns result
        assert!(iter.next().is_some());

        // Subsequent calls should always return None (FusedIterator)
        assert!(iter.next().is_none());
        assert!(iter.next().is_none());
        assert!(iter.next().is_none());
    }

    #[test]
    fn test_iterator_empty() {
        let raw_results: Vec<(PathBuf, Vec<Range>)> = vec![];
        let mut iter = SearchResultIterator::new(raw_results);

        assert_eq!(iter.remaining(), 0);
        assert_eq!(iter.size_hint(), (0, Some(0)));
        assert!(iter.next().is_none());
    }

    #[test]
    fn test_search_result_iterator_is_send() {
        fn assert_send<T: Send>() {}
        assert_send::<SearchResultIterator>();
    }
}
```

#### Integration Test: Verify Lazy Loading

To fully verify lazy loading behavior, create a test that monitors file access:

```rust
#[test]
fn test_lazy_loading_with_monitoring() {
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::cell::RefCell;

    // In a real test, you would wrap fs::read_to_string to count calls
    // This demonstrates the expected behavior

    let temp_dir = TempDir::new().unwrap();
    let files: Vec<_> = (0..1000)
        .map(|i| {
            let file = temp_dir.path().join(format!("test{}.rs", i));
            std::fs::write(&file, format!("// File {}\nfn main() {{}}", i)).unwrap();
            file
        })
        .collect();

    let raw_results: Vec<_> = files.iter().map(|f| (f.clone(), vec![])).collect();

    let iter = SearchResultIterator::new(raw_results);

    // Take only 5
    let results: Vec<_> = iter.take(5).collect::<Result<Vec<_>, _>>().unwrap();

    assert_eq!(results.len(), 5);
    // In a real monitored test, we would verify that only 5 files were read
}
```

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation provides memory-efficient lazy iteration over search results. File content is loaded only when consumed, enabling early termination and processing of large result sets without excessive memory usage.

**Implementation Highlights:**
- Lazy loading in `next()` - file read only when item consumed
- Proper error handling with path context in error messages
- Iterator continues after errors (doesn't short-circuit)
- `ranges_to_matches` helper with safe bounds checking
- Line number conversion from 0-indexed to 1-indexed
- Struct derives Debug and Clone for debugging and cloning support

**Code Location:** `rdump/src/lib.rs:368-423`

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ No unwrap() on user data, proper error handling
- Project Structure: ✓ Code is in correct location (src/lib.rs)
- Testing Strategy: ✓ All 4 iterator tests pass
- All ACs Met: ✓ All 11 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

- [x] Implements Iterator<Item = Result<SearchResult>> (lines 389-390)
- [x] Implements ExactSizeIterator (line 421)
- [x] Implements FusedIterator (line 423)
- [x] size_hint() returns accurate values (lines 415-418)
- [x] File content loaded only in next() (lines 395-404)
- [x] One file in memory at a time (lazy loading design)
- [x] Early termination prevents unnecessary reads (take(n) works)
- [x] File read errors returned as Err (lines 397-403)
- [x] Error includes file path (lines 398-401)
- [x] Iterator continues after error (returns error as item)
- [x] remaining() returns count (lines 383-386)

### Security Review

No security concerns - proper file path handling and bounds checking in ranges_to_matches.

### Performance Considerations

**Memory efficient:**
- Lazy loading means only one file's content in memory at a time
- Early termination with `.take(n)` reads only n files
- No upfront loading of all file contents

**Comparison:**
- 1000 files with take(5): ~50KB vs ~10MB without lazy loading
- Enables processing unlimited result sets

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.6-create-searchresultiterator.yml

### Recommended Status

✓ Ready for Done

All 11 acceptance criteria have been met, all 4 tests pass, and the implementation provides memory-efficient lazy iteration over search results.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
