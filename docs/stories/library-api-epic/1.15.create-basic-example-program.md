# Story 1.15: Create Basic Example Program

## Status
Draft

## Story
**As a** library user,
**I want** a comprehensive example demonstrating library usage patterns,
**so that** I can quickly learn common use cases and get started with the API.

## Acceptance Criteria

**Compilation:**
1. - [ ] Example compiles without warnings
2. - [ ] Example runs successfully
3. - [ ] Works with `cargo run --example basic_search`

**Content:**
4. - [ ] Shows extension search pattern
5. - [ ] Shows function search pattern
6. - [ ] Shows compound query pattern
7. - [ ] Shows custom SearchOptions usage
8. - [ ] Shows how to work with SearchResult and Match structs
9. - [ ] Includes helpful comments explaining each part

**Output:**
10. - [ ] Produces readable, formatted output
11. - [ ] Handles edge cases (empty results, many results)
12. - [ ] Shows practical information about results

## Tasks / Subtasks

- [ ] Create example file `examples/basic_search.rs` (AC: 1, 2, 3)
- [ ] Implement example functions (AC: 4-8)
  - [ ] `example_extension_search()` - find files by extension
  - [ ] `example_function_search()` - find functions by name
  - [ ] `example_compound_query()` - AND/OR/NOT queries
  - [ ] `example_custom_options()` - all SearchOptions fields
  - [ ] `example_working_with_results()` - Match and SearchResult usage
- [ ] Add utility examples (additional patterns)
  - [ ] Count functions per file
  - [ ] Collect function names
  - [ ] Filter results programmatically
- [ ] Add helpful comments (AC: 9)
- [ ] Ensure readable output (AC: 10, 11, 12)

## Dev Notes

### Location
- Example file: `examples/basic_search.rs`
- [Source: docs/epics/library-api-epic.md - Story 15]

### Why These Examples?
1. **Extension search**: Most common use case
2. **Function search**: Shows semantic search capability
3. **Compound queries**: Shows query language power
4. **Custom options**: Shows all configuration options
5. **Working with results**: Shows how to process results

### Running the Example
```bash
# From project root
cargo run --example basic_search

# With a specific directory
cd /path/to/project
cargo run --example basic_search --manifest-path /path/to/rdump/Cargo.toml
```

### Example Structure
```rust
fn main() -> Result<()> {
    println!("rdump Library API Examples\n");

    example_extension_search()?;
    example_function_search()?;
    example_compound_query()?;
    example_custom_options()?;
    example_working_with_results()?;

    println!("\nAll examples completed successfully!");
    Ok(())
}
```

### Complete Implementation

```rust
//! Basic rdump library usage example
//!
//! Demonstrates common patterns for using the rdump library API.
//!
//! Run with: cargo run --example basic_search

use anyhow::Result;
use rdump::{search, SearchOptions, SearchResult, SqlDialect};
use std::path::PathBuf;

fn main() -> Result<()> {
    println!("rdump Library API Examples\n");

    // Example 1: Simple extension search
    example_extension_search()?;

    // Example 2: Semantic function search
    example_function_search()?;

    // Example 3: Compound queries
    example_compound_query()?;

    // Example 4: Custom search options
    example_custom_options()?;

    // Example 5: Working with results
    example_working_with_results()?;

    println!("\nAll examples completed successfully!");
    Ok(())
}

/// Example 1: Search by file extension
fn example_extension_search() -> Result<()> {
    println!("=== Example 1: Extension Search ===");

    // Find all Rust files in current directory
    let results = search("ext:rs", SearchOptions::default())?;

    println!("Found {} Rust files:", results.len());
    for result in results.iter().take(5) {
        println!("  - {}", result.path.display());
    }
    if results.len() > 5 {
        println!("  ... and {} more", results.len() - 5);
    }

    println!();
    Ok(())
}

/// Example 2: Search for functions by name
fn example_function_search() -> Result<()> {
    println!("=== Example 2: Function Search ===");

    // Find all files containing a 'main' function
    let results = search("func:main", SearchOptions::default())?;

    println!("Found {} files with main function:", results.len());
    for result in &results {
        if result.is_whole_file_match() {
            println!("  {} (whole file match)", result.path.display());
        } else {
            for m in &result.matches {
                println!(
                    "  {}:{} - {}",
                    result.path.display(),
                    m.start_line,
                    m.first_line()
                );
            }
        }
    }

    println!();
    Ok(())
}

/// Example 3: Compound queries with AND/OR
fn example_compound_query() -> Result<()> {
    println!("=== Example 3: Compound Query ===");

    // Find Rust files that contain either 'test' or 'main' function
    let query = "ext:rs & (func:test | func:main)";
    let results = search(query, SearchOptions::default())?;

    println!("Query: {}", query);
    println!("Found {} matching files:", results.len());
    for result in results.iter().take(5) {
        println!("  - {} ({} matches)",
            result.path.display(),
            result.match_count()
        );
    }

    println!();
    Ok(())
}

/// Example 4: Custom search options
fn example_custom_options() -> Result<()> {
    println!("=== Example 4: Custom Options ===");

    // Create custom options for a specific search
    let options = SearchOptions {
        // Search in a specific directory
        root: PathBuf::from("."),

        // Use a preset to limit to specific file types
        presets: vec!["rust".to_string()],

        // Include hidden files (like .github)
        hidden: true,

        // Ignore .gitignore rules
        no_ignore: false,

        // Limit directory depth
        max_depth: Some(3),

        // Use default SQL dialect (auto-detect)
        sql_dialect: None,
    };

    let results = search("", options)?;

    println!("Custom search found {} files", results.len());
    for result in results.iter().take(3) {
        println!("  - {}", result.path.display());
    }

    println!();
    Ok(())
}

/// Example 5: Working with search results
fn example_working_with_results() -> Result<()> {
    println!("=== Example 5: Working with Results ===");

    let results = search("func:new", SearchOptions::default())?;

    if results.is_empty() {
        println!("No results found");
        return Ok(());
    }

    // Get the first result
    let result = &results[0];

    println!("First result: {}", result.path.display());
    println!("  Content length: {} bytes", result.content.len());
    println!("  Is whole file match: {}", result.is_whole_file_match());
    println!("  Match count: {}", result.match_count());

    // If there are specific matches, show details
    if !result.is_whole_file_match() {
        println!("  Matched lines: {:?}", result.matched_lines());

        for (i, m) in result.matches.iter().enumerate() {
            println!("\n  Match {}:", i + 1);
            println!("    Lines: {}-{}", m.start_line, m.end_line);
            println!("    Columns: {}-{}", m.start_column, m.end_column);
            println!("    Bytes: {:?}", m.byte_range);
            println!("    Multiline: {}", m.is_multiline());

            // Show first few characters of matched text
            let preview: String = m.text.chars().take(50).collect();
            if m.text.len() > 50 {
                println!("    Text: {}...", preview);
            } else {
                println!("    Text: {}", preview);
            }
        }
    }

    println!();
    Ok(())
}

// =============================================================================
// Additional utility examples
// =============================================================================

/// Example: Find and count function definitions per file
#[allow(dead_code)]
fn count_functions_per_file() -> Result<()> {
    let results = search("func:*", SearchOptions {
        presets: vec!["rust".to_string()],
        ..Default::default()
    })?;

    let mut files_with_counts: Vec<_> = results
        .iter()
        .map(|r| (r.path.clone(), r.match_count()))
        .collect();

    // Sort by function count descending
    files_with_counts.sort_by(|a, b| b.1.cmp(&a.1));

    println!("Files by function count:");
    for (path, count) in files_with_counts.iter().take(10) {
        println!("  {:>3} functions: {}", count, path.display());
    }

    Ok(())
}

/// Example: Collect all function names in a project
#[allow(dead_code)]
fn collect_function_names() -> Result<Vec<String>> {
    let results = search("func:*", SearchOptions::default())?;

    let mut function_names = Vec::new();

    for result in &results {
        for m in &result.matches {
            // Extract function name from first line
            // This is a simplified example; actual extraction would need parsing
            if let Some(name) = extract_function_name(&m.text) {
                function_names.push(name);
            }
        }
    }

    Ok(function_names)
}

fn extract_function_name(text: &str) -> Option<String> {
    // Simplified extraction - real implementation would use tree-sitter
    let line = text.lines().next()?;
    if line.contains("fn ") {
        let start = line.find("fn ")? + 3;
        let end = line[start..].find('(')?;
        Some(line[start..start + end].trim().to_string())
    } else {
        None
    }
}

/// Example: Filter results programmatically
#[allow(dead_code)]
fn filter_results_example() -> Result<()> {
    let results = search("ext:rs", SearchOptions::default())?;

    // Filter to only files in src directory
    let src_files: Vec<_> = results
        .iter()
        .filter(|r| r.path.to_string_lossy().contains("/src/"))
        .collect();

    // Filter to files with certain content
    let with_unsafe: Vec<_> = results
        .iter()
        .filter(|r| r.content.contains("unsafe"))
        .collect();

    println!("Files in src: {}", src_files.len());
    println!("Files with unsafe: {}", with_unsafe.len());

    Ok(())
}
```

### Testing

**Test Location:** Example runs as integration test

**Verification:**
- `cargo run --example basic_search` completes successfully
- Output is readable and informative
- No warnings during compilation
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
