# Story 1.15: Create Basic Example Program

## Status
Done

## Story
**As a** library user,
**I want** a comprehensive example demonstrating library usage patterns,
**so that** I can quickly learn common use cases and get started with the API.

## Acceptance Criteria

**Compilation:**
1. - [x] Example compiles without warnings
2. - [x] Example runs successfully
3. - [x] Works with `cargo run --example basic_search`

**Content:**
4. - [x] Shows extension search pattern
5. - [x] Shows function search pattern
6. - [x] Shows compound query pattern
7. - [x] Shows custom SearchOptions usage
8. - [x] Shows how to work with SearchResult and Match structs
9. - [x] Includes helpful comments explaining each part

**Output:**
10. - [x] Produces readable, formatted output
11. - [x] Handles edge cases (empty results, many results)
12. - [x] Shows practical information about results

## Tasks / Subtasks

- [x] Create example file `examples/basic_search.rs` (AC: 1, 2, 3)
- [x] Implement example functions (AC: 4-8)
  - [x] `example_extension_search()` - find files by extension
  - [x] `example_function_search()` - find functions by name
  - [x] `example_compound_query()` - AND/OR/NOT queries
  - [x] `example_custom_options()` - all SearchOptions fields
  - [x] `example_working_with_results()` - Match and SearchResult usage
- [x] Add utility examples (additional patterns)
  - [x] Count functions per file
  - [x] Collect function names
  - [x] Filter results programmatically
- [x] Add helpful comments (AC: 9)
- [x] Ensure readable output (AC: 10, 11, 12)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `examples/basic_search.rs` demonstrating extension, function, and compound queries, custom `SearchOptions`, result inspection, and utility patterns (count/collect/filter) using the fixture project for deterministic output.
  - Uses streaming iterator to skip per-file errors gracefully; includes readable headings and handles empty-result cases.
  - Verified with `cargo run --example basic_search`.
- File List:
  - rdump/examples/basic_search.rs

## Dev Notes

### Location
- Example file: `examples/basic_search.rs`
- [Source: docs/epics/library-api-epic.md - Story 15]

### Why These Examples?
1. **Extension search**: Most common use case
2. **Function search**: Shows semantic search capability
3. **Compound queries**: Shows query language power
4. **Custom options**: Shows all configuration options
5. **Working with results**: Shows how to process results

### Running the Example
```bash
# From project root
cargo run --example basic_search

# With a specific directory
cd /path/to/project
cargo run --example basic_search --manifest-path /path/to/rdump/Cargo.toml
```

### Example Structure
```rust
fn main() -> Result<()> {
    println!("rdump Library API Examples\n");

    example_extension_search()?;
    example_function_search()?;
    example_compound_query()?;
    example_custom_options()?;
    example_working_with_results()?;

    println!("\nAll examples completed successfully!");
    Ok(())
}
```

### Complete Implementation

```rust
//! Basic rdump library usage example
//!
//! Demonstrates common patterns for using the rdump library API.
//!
//! Run with: cargo run --example basic_search

use anyhow::Result;
use rdump::{search, SearchOptions, SearchResult, SqlDialect};
use std::path::PathBuf;

fn main() -> Result<()> {
    println!("rdump Library API Examples\n");

    // Example 1: Simple extension search
    example_extension_search()?;

    // Example 2: Semantic function search
    example_function_search()?;

    // Example 3: Compound queries
    example_compound_query()?;

    // Example 4: Custom search options
    example_custom_options()?;

    // Example 5: Working with results
    example_working_with_results()?;

    println!("\nAll examples completed successfully!");
    Ok(())
}

/// Example 1: Search by file extension
fn example_extension_search() -> Result<()> {
    println!("=== Example 1: Extension Search ===");

    // Find all Rust files in current directory
    let results = search("ext:rs", SearchOptions::default())?;

    println!("Found {} Rust files:", results.len());
    for result in results.iter().take(5) {
        println!("  - {}", result.path.display());
    }
    if results.len() > 5 {
        println!("  ... and {} more", results.len() - 5);
    }

    println!();
    Ok(())
}

/// Example 2: Search for functions by name
fn example_function_search() -> Result<()> {
    println!("=== Example 2: Function Search ===");

    // Find all files containing a 'main' function
    let results = search("func:main", SearchOptions::default())?;

    println!("Found {} files with main function:", results.len());
    for result in &results {
        if result.is_whole_file_match() {
            println!("  {} (whole file match)", result.path.display());
        } else {
            for m in &result.matches {
                println!(
                    "  {}:{} - {}",
                    result.path.display(),
                    m.start_line,
                    m.first_line()
                );
            }
        }
    }

    println!();
    Ok(())
}

/// Example 3: Compound queries with AND/OR
fn example_compound_query() -> Result<()> {
    println!("=== Example 3: Compound Query ===");

    // Find Rust files that contain either 'test' or 'main' function
    let query = "ext:rs & (func:test | func:main)";
    let results = search(query, SearchOptions::default())?;

    println!("Query: {}", query);
    println!("Found {} matching files:", results.len());
    for result in results.iter().take(5) {
        println!("  - {} ({} matches)",
            result.path.display(),
            result.match_count()
        );
    }

    println!();
    Ok(())
}

/// Example 4: Custom search options
fn example_custom_options() -> Result<()> {
    println!("=== Example 4: Custom Options ===");

    // Create custom options for a specific search
    let options = SearchOptions {
        // Search in a specific directory
        root: PathBuf::from("."),

        // Use a preset to limit to specific file types
        presets: vec!["rust".to_string()],

        // Include hidden files (like .github)
        hidden: true,

        // Ignore .gitignore rules
        no_ignore: false,

        // Limit directory depth
        max_depth: Some(3),

        // Use default SQL dialect (auto-detect)
        sql_dialect: None,
    };

    let results = search("", options)?;

    println!("Custom search found {} files", results.len());
    for result in results.iter().take(3) {
        println!("  - {}", result.path.display());
    }

    println!();
    Ok(())
}

/// Example 5: Working with search results
fn example_working_with_results() -> Result<()> {
    println!("=== Example 5: Working with Results ===");

    let results = search("func:new", SearchOptions::default())?;

    if results.is_empty() {
        println!("No results found");
        return Ok(());
    }

    // Get the first result
    let result = &results[0];

    println!("First result: {}", result.path.display());
    println!("  Content length: {} bytes", result.content.len());
    println!("  Is whole file match: {}", result.is_whole_file_match());
    println!("  Match count: {}", result.match_count());

    // If there are specific matches, show details
    if !result.is_whole_file_match() {
        println!("  Matched lines: {:?}", result.matched_lines());

        for (i, m) in result.matches.iter().enumerate() {
            println!("\n  Match {}:", i + 1);
            println!("    Lines: {}-{}", m.start_line, m.end_line);
            println!("    Columns: {}-{}", m.start_column, m.end_column);
            println!("    Bytes: {:?}", m.byte_range);
            println!("    Multiline: {}", m.is_multiline());

            // Show first few characters of matched text
            let preview: String = m.text.chars().take(50).collect();
            if m.text.len() > 50 {
                println!("    Text: {}...", preview);
            } else {
                println!("    Text: {}", preview);
            }
        }
    }

    println!();
    Ok(())
}

// =============================================================================
// Additional utility examples
// =============================================================================

/// Example: Find and count function definitions per file
#[allow(dead_code)]
fn count_functions_per_file() -> Result<()> {
    let results = search("func:*", SearchOptions {
        presets: vec!["rust".to_string()],
        ..Default::default()
    })?;

    let mut files_with_counts: Vec<_> = results
        .iter()
        .map(|r| (r.path.clone(), r.match_count()))
        .collect();

    // Sort by function count descending
    files_with_counts.sort_by(|a, b| b.1.cmp(&a.1));

    println!("Files by function count:");
    for (path, count) in files_with_counts.iter().take(10) {
        println!("  {:>3} functions: {}", count, path.display());
    }

    Ok(())
}

/// Example: Collect all function names in a project
#[allow(dead_code)]
fn collect_function_names() -> Result<Vec<String>> {
    let results = search("func:*", SearchOptions::default())?;

    let mut function_names = Vec::new();

    for result in &results {
        for m in &result.matches {
            // Extract function name from first line
            // This is a simplified example; actual extraction would need parsing
            if let Some(name) = extract_function_name(&m.text) {
                function_names.push(name);
            }
        }
    }

    Ok(function_names)
}

fn extract_function_name(text: &str) -> Option<String> {
    // Simplified extraction - real implementation would use tree-sitter
    let line = text.lines().next()?;
    if line.contains("fn ") {
        let start = line.find("fn ")? + 3;
        let end = line[start..].find('(')?;
        Some(line[start..start + end].trim().to_string())
    } else {
        None
    }
}

/// Example: Filter results programmatically
#[allow(dead_code)]
fn filter_results_example() -> Result<()> {
    let results = search("ext:rs", SearchOptions::default())?;

    // Filter to only files in src directory
    let src_files: Vec<_> = results
        .iter()
        .filter(|r| r.path.to_string_lossy().contains("/src/"))
        .collect();

    // Filter to files with certain content
    let with_unsafe: Vec<_> = results
        .iter()
        .filter(|r| r.content.contains("unsafe"))
        .collect();

    println!("Files in src: {}", src_files.len());
    println!("Files with unsafe: {}", with_unsafe.len());

    Ok(())
}
```

### Testing

**Test Location:** Example runs as integration test

**Verification:**
- `cargo run --example basic_search` completes successfully
- Output is readable and informative
- No warnings during compilation
- [Source: docs/architecture.md#test-strategy]

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Well-structured example program demonstrating all key library API patterns. Uses a fixture-based approach for deterministic output with clean helper functions and readable formatting.

**Implementation Highlights:**
- 5 core examples covering all major use cases
- Helper functions: `run_query()`, `report_results()`, `describe_match()`, `print_heading()`
- Uses `search_iter` with `filter_map(Result::ok)` to skip file errors gracefully
- Fixture-based testing via `tests/fixtures/rust_project/`
- Utility patterns section shows count/collect/filter/streaming patterns

**Code Location:** `rdump/examples/basic_search.rs` (227 lines)

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ Idiomatic Rust with proper documentation
- Project Structure: ✓ Example in correct location
- Testing Strategy: ✓ Builds and runs successfully
- All ACs Met: ✓ All 12 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

**Compilation (3/3):**
- [x] Example compiles without warnings
- [x] Example runs successfully ("All examples completed successfully!")
- [x] Works with `cargo run --example basic_search`

**Content (6/6):**
- [x] Shows extension search pattern (lines 25-38)
- [x] Shows function search pattern (lines 40-72)
- [x] Shows compound query pattern (lines 74-90)
- [x] Shows custom SearchOptions usage (lines 92-108)
- [x] Shows how to work with SearchResult and Match structs (lines 110-137)
- [x] Includes helpful comments explaining each part (doc comments on all functions)

**Output (3/3):**
- [x] Produces readable, formatted output (headings with underlines, proper indentation)
- [x] Handles edge cases (empty results check at line 51, "and N more" at line 199)
- [x] Shows practical information (match count, lines, bytes, first_line)

### Security Review

No security concerns - example uses fixture directory for deterministic results.

### Performance Considerations

**Efficient design:**
- Uses `search_iter` for streaming pattern demonstration
- Early termination example with `.take(2)`
- Filter gracefully skips errors instead of failing

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.15-create-basic-example-program.yml

### Recommended Status

✓ Ready for Done

All 12 acceptance criteria have been met, example compiles and runs successfully, demonstrating all key library API patterns with readable output.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 0.2 | Added basic library example program and verified run | Dev Agent |
| 2025-11-21 | 1.0 | QA Review completed - all 12 ACs verified | Quinn (QA) |
