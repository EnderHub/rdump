# Story 1.22: Export Async API

## Status
Draft

## Story
**As a** library user,
**I want** async functions exported from lib.rs under feature gate,
**so that** they're only compiled and visible when the `async` feature is enabled.

## Acceptance Criteria

**Feature Gating:**
1. - [ ] `search_async` only exported with `async` feature
2. - [ ] `search_all_async` only exported with `async` feature
3. - [ ] `async_api` module only compiled with `async` feature
4. - [ ] No async types leak without feature

**Build Verification:**
5. - [ ] `cargo build` succeeds without async imports
6. - [ ] `cargo build --features async` succeeds with async imports
7. - [ ] `use rdump::search_async` fails without feature
8. - [ ] `use rdump::search_async` succeeds with feature

**Documentation:**
9. - [ ] `cargo doc` shows async functions only when feature enabled
10. - [ ] Feature requirement noted in function docs

## Tasks / Subtasks

- [ ] Add conditional module compilation to `src/lib.rs` (AC: 1, 2, 3)
  - [ ] `#[cfg(feature = "async")] mod async_api;`
  - [ ] `#[cfg(feature = "async")] pub use async_api::*;`
- [ ] Organize with other exports (AC: 4)
  - [ ] Add Async API section in exports
  - [ ] Keep separate from sync API
- [ ] Verify builds (AC: 5, 6, 7, 8)
- [ ] Check documentation generation (AC: 9, 10)

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 22]

### Why Feature Gate at Module Level?
```rust
// Good - module not compiled without feature
#[cfg(feature = "async")]
mod async_api;

// Bad - module always compiled, just not exported
mod async_api;
#[cfg(feature = "async")]
pub use async_api::*;
```

The first approach:
1. Faster compilation without feature
2. No dead code warnings
3. Dependencies not linked

### Export Organization
```rust
// =============================================================================
// Library API - Sync
// =============================================================================

pub use search_types::{Match, SearchOptions, SearchResult, SearchResultIterator};
pub use api::{search, search_iter};
pub use predicates::code_aware::SqlDialect;

// =============================================================================
// Library API - Async (feature-gated)
// =============================================================================

#[cfg(feature = "async")]
mod async_api;

#[cfg(feature = "async")]
pub use async_api::{search_async, search_all_async};

// =============================================================================
// CLI API (unchanged)
// =============================================================================

pub use args::SearchArgs;
```

### Complete Implementation

#### src/lib.rs Changes

```rust
// =============================================================================
// Library API - Sync
// =============================================================================

// Types
pub use search_types::{Match, SearchOptions, SearchResult, SearchResultIterator};

// Functions
pub use api::{search, search_iter};

// Re-exports
pub use predicates::code_aware::SqlDialect;

// =============================================================================
// Library API - Async (feature-gated)
// =============================================================================

/// Async search API module (requires `async` feature)
#[cfg(feature = "async")]
mod async_api;

/// Re-export async functions at crate root
#[cfg(feature = "async")]
pub use async_api::{search_async, search_all_async};

// =============================================================================
// CLI API (unchanged)
// =============================================================================

pub use args::SearchArgs;
// ... other CLI exports
```

### Verification Test

```rust
// In tests/api_exports.rs

#[test]
fn test_sync_exports() {
    // Always available
    use rdump::{search, search_iter, SearchOptions, SearchResult, Match};
    let _ = SearchOptions::default();
}

#[test]
#[cfg(feature = "async")]
fn test_async_exports() {
    // Only with async feature
    use rdump::{search_async, search_all_async};
    // Can't easily test without runtime, just verify import works
}

#[test]
fn test_async_not_visible_without_feature() {
    // This would fail to compile if async exports leaked
    // We can't test this directly, but cargo build without
    // the feature should succeed
}
```

### Testing

**Test Location:** `tests/api_exports.rs`

**Test Cases:**
- Sync exports always work
- Async exports only with feature
- Build verification both ways
- [Source: docs/architecture.md#test-strategy]

**Build Verification Commands:**
```bash
# Verify without async feature
cargo build
# Should succeed - async exports not visible

# Verify with async feature
cargo build --features async
# Should succeed - async exports available

# Documentation with feature
cargo doc --features async
# Should show async functions in docs
```

**Complete Test File:**
```rust
//! Export verification tests
//!
//! Run with: cargo test --test api_exports
//! Run with async: cargo test --features async --test api_exports

#[test]
fn test_sync_exports_always_available() {
    // These should always compile and be available
    use rdump::{search, search_iter, SearchOptions, SearchResult, Match};

    // Verify we can create instances
    let options = SearchOptions::default();
    assert!(options.root.as_os_str().len() > 0);
}

#[test]
fn test_searchoptions_clone() {
    use rdump::SearchOptions;
    let options = SearchOptions::default();
    let cloned = options.clone();
    assert_eq!(options.root, cloned.root);
}

#[test]
#[cfg(feature = "async")]
fn test_async_exports_with_feature() {
    // These should only be available with the async feature
    use rdump::{search_async, search_all_async};

    // We can verify the functions exist by referencing them
    let _ = search_async as fn(&str, rdump::SearchOptions) -> _;
    let _ = search_all_async as fn(&str, rdump::SearchOptions) -> _;
}

#[cfg(feature = "async")]
#[tokio::test]
async fn test_async_function_signatures() {
    use rdump::{search_async, search_all_async, SearchOptions};
    use tempfile::tempdir;
    use std::fs;

    let dir = tempdir().unwrap();
    fs::write(dir.path().join("test.rs"), "fn main() {}").unwrap();

    // Verify search_async returns a stream
    let stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await;
    assert!(stream.is_ok());

    // Verify search_all_async returns a Vec
    let results = search_all_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await;
    assert!(results.is_ok());
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
