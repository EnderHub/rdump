# Story 1.9: Create search_iter Public Function

## Status
Draft

## Story
**As a** library user,
**I want** a primary public API function for streaming search,
**so that** I can efficiently search large codebases with memory-efficient iteration.

## Acceptance Criteria

1. - [ ] Public function in `rdump` crate root
2. - [ ] Takes `&str` query and owned `SearchOptions`
3. - [ ] Returns `Result<SearchResultIterator>`
4. - [ ] Invalid query returns `Err` immediately
5. - [ ] Nonexistent root returns `Err` immediately
6. - [ ] Unknown preset returns `Err` immediately
7. - [ ] Empty query matches all files (based on presets)
8. - [ ] Rustdoc with full description
9. - [ ] Documents all error conditions
10. - [ ] Multiple examples showing common patterns
11. - [ ] Explains when to use this vs `search()`

## Tasks / Subtasks

- [ ] Create `search_iter` function in `src/lib.rs` (AC: 1, 2, 3)
  - [ ] Accept `query: &str` and `options: SearchOptions`
  - [ ] Call `perform_search_internal`
  - [ ] Wrap results in SearchResultIterator
- [ ] Implement error handling (AC: 4, 5, 6)
  - [ ] Validate query syntax
  - [ ] Check root directory exists
  - [ ] Validate preset names
- [ ] Handle empty query (AC: 7)
- [ ] Add comprehensive rustdoc (AC: 8, 9, 10, 11)
  - [ ] Basic usage example
  - [ ] Early termination example
  - [ ] Skip errors example
- [ ] Write integration tests

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 9]

### Complete Implementation

```rust
/// Search for files matching a query (streaming, memory-efficient)
///
/// Returns an iterator that yields results one at a time, loading file
/// content only when each result is consumed. This is the recommended
/// API for large codebases.
///
/// # Arguments
///
/// * `query` - An RQL (rdump query language) query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// An iterator yielding `Result<SearchResult>` for each matching file.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - A preset name is not found
///
/// # Example
///
/// ```rust
/// use rdump::{search_iter, SearchOptions};
///
/// let results = search_iter(
///     "ext:rs & func:main",
///     SearchOptions::default(),
/// )?;
///
/// for result in results {
///     let result = result?;
///     println!("{}: {} matches",
///         result.path.display(),
///         result.matches.len()
///     );
/// }
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// # Early Termination
///
/// ```rust
/// // Find first 10 matches only
/// let first_ten: Vec<_> = search_iter("ext:rs", options)?
///     .take(10)
///     .collect::<Result<Vec<_>, _>>()?;
/// ```
///
/// # Error Handling
///
/// ```rust
/// // Skip files that can't be read
/// let results: Vec<_> = search_iter("ext:rs", options)?
///     .filter_map(Result::ok)
///     .collect();
/// ```
pub fn search_iter(
    query: &str,
    options: SearchOptions,
) -> Result<SearchResultIterator> {
    let raw_results = commands::search::perform_search_internal(query, &options)?;
    Ok(SearchResultIterator::new(raw_results))
}
```

### Why SearchOptions is Owned, Not Borrowed
Taking ownership avoids lifetime parameters in the return type. Since `SearchOptions` is cheap to construct and users typically create it inline, this is ergonomic:
```rust
// Clean API - no lifetime annotations
let iter = search_iter("query", SearchOptions::default())?;

// vs requiring a reference (would need lifetime)
let options = SearchOptions::default();
let iter = search_iter("query", &options)?;  // iter borrows options
// options must outlive iter
```

### Usage Patterns

#### Basic Iteration
```rust
use rdump::{search_iter, SearchOptions};

let results = search_iter("ext:rs & func:main", SearchOptions::default())?;
for result in results {
    let result = result?;
    println!("{}: {} matches", result.path.display(), result.matches.len());
}
```

#### Early Termination (Memory Efficient)
```rust
// Find first 10 matches only - stops iteration early
let first_ten: Vec<_> = search_iter("ext:rs", options)?
    .take(10)
    .collect::<Result<Vec<_>, _>>()?;
```

#### Skip Errors (Graceful Degradation)
```rust
// Skip files that can't be read
let results: Vec<_> = search_iter("ext:rs", options)?
    .filter_map(Result::ok)
    .collect();
```

#### Count Without Loading Content
```rust
// Count matches without loading all content into memory
let count = search_iter("ext:rs", options)?
    .filter_map(Result::ok)
    .count();
```

#### With Custom Options
```rust
use std::path::PathBuf;
use rdump::{search_iter, SearchOptions, SqlDialect};

let results = search_iter(
    "lang:sql & select",
    SearchOptions {
        root: PathBuf::from("/projects/myapp"),
        presets: vec!["default".to_string()],
        no_ignore: false,
        hidden: false,
        max_depth: Some(10),
        sql_dialect: Some(SqlDialect::Postgresql),
    },
)?;
```

### Complete Test Cases

**Test Location:** `tests/library_api.rs`

```rust
use rdump::{search_iter, SearchOptions};
use std::fs;
use tempfile::tempdir;

#[test]
fn test_search_iter_basic() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results: Vec<_> = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
}

#[test]
fn test_search_iter_early_termination() {
    let dir = tempdir().unwrap();

    // Create 10 files
    for i in 0..10 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    // Only take first 3
    let results: Vec<_> = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .take(3)
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 3);
}

#[test]
fn test_search_iter_invalid_query() {
    let dir = tempdir().unwrap();

    let result = search_iter("invalid::: query syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_nonexistent_root() {
    let result = search_iter("ext:rs", SearchOptions {
        root: std::path::PathBuf::from("/nonexistent/path"),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_unknown_preset() {
    let dir = tempdir().unwrap();

    let result = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["nonexistent_preset".to_string()],
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_empty_query() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    // Empty query should match based on presets
    let results: Vec<_> = search_iter("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string()],
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
}

#[test]
fn test_search_iter_skip_errors() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete file after creating iterator
    fs::remove_file(&file).unwrap();

    // Skip errors gracefully
    let results: Vec<_> = iter.filter_map(Result::ok).collect();
    assert_eq!(results.len(), 0);
}

#[test]
fn test_search_iter_with_func_query() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn my_function() {\n    println!(\"hello\");\n}").unwrap();

    let results: Vec<_> = search_iter("func:my_function", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
    assert!(!results[0].matches.is_empty());
    assert!(results[0].matches[0].text.contains("my_function"));
}

#[test]
fn test_search_iter_count_only() {
    let dir = tempdir().unwrap();

    for i in 0..5 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    let count = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .filter_map(Result::ok)
    .count();

    assert_eq!(count, 5);
}
```

### Technical Notes

**Error Propagation:**
- Query parsing errors are returned immediately from `search_iter()`
- File reading errors are returned per-item from the iterator
- This allows users to handle setup errors differently from runtime errors

**Memory Efficiency:**
- Only one file's content is loaded at a time
- Previous results are dropped as iteration proceeds
- Ideal for processing large codebases

- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
