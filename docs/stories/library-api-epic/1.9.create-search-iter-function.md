# Story 1.9: Create search_iter Public Function

## Status
Done

## Story
**As a** library user,
**I want** a primary public API function for streaming search,
**so that** I can efficiently search large codebases with memory-efficient iteration.

## Acceptance Criteria

1. - [x] Public function in `rdump` crate root
2. - [x] Takes `&str` query and owned `SearchOptions`
3. - [x] Returns `Result<SearchResultIterator>`
4. - [x] Invalid query returns `Err` immediately
5. - [x] Nonexistent root returns `Err` immediately
6. - [x] Unknown preset returns `Err` immediately
7. - [x] Empty query matches all files (based on presets)
8. - [x] Rustdoc with full description
9. - [x] Documents all error conditions
10. - [x] Multiple examples showing common patterns
11. - [x] Explains when to use this vs `search()`

## Tasks / Subtasks

- [x] Create `search_iter` function in `src/lib.rs` (AC: 1, 2, 3)
  - [x] Accept `query: &str` and `options: SearchOptions`
  - [x] Call `perform_search_internal`
  - [x] Wrap results in SearchResultIterator
- [x] Implement error handling (AC: 4, 5, 6)
  - [x] Validate query syntax
  - [x] Check root directory exists
  - [x] Validate preset names
- [x] Handle empty query (AC: 7)
- [x] Add comprehensive rustdoc (AC: 8, 9, 10, 11)
  - [x] Basic usage example
  - [x] Early termination example
  - [x] Skip errors example
- [x] Write integration tests

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `search_iter` public API with rustdoc covering usage, errors, and streaming guidance; owns `SearchOptions` and delegates to `perform_search_internal`.
  - Expanded tests (`tests/search_iter.rs`) for basic usage, early termination, invalid query, missing root, unknown preset, empty query with preset, skipping errors, and count-only iteration, using repo-local config override for presets.
  - Maintained error semantics: invalid queries/presets/roots error early; iterator surfaces per-file errors lazily.
- File List:
  - rdump/src/lib.rs
  - rdump/tests/search_iter.rs

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 9]

### Complete Implementation

```rust
/// Search for files matching a query (streaming, memory-efficient)
///
/// Returns an iterator that yields results one at a time, loading file
/// content only when each result is consumed. This is the recommended
/// API for large codebases.
///
/// # Arguments
///
/// * `query` - An RQL (rdump query language) query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// An iterator yielding `Result<SearchResult>` for each matching file.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - A preset name is not found
///
/// # Example
///
/// ```rust
/// use rdump::{search_iter, SearchOptions};
///
/// let results = search_iter(
///     "ext:rs & func:main",
///     SearchOptions::default(),
/// )?;
///
/// for result in results {
///     let result = result?;
///     println!("{}: {} matches",
///         result.path.display(),
///         result.matches.len()
///     );
/// }
/// # Ok::<(), anyhow::Error>(())
/// ```
///
/// # Early Termination
///
/// ```rust
/// // Find first 10 matches only
/// let first_ten: Vec<_> = search_iter("ext:rs", options)?
///     .take(10)
///     .collect::<Result<Vec<_>, _>>()?;
/// ```
///
/// # Error Handling
///
/// ```rust
/// // Skip files that can't be read
/// let results: Vec<_> = search_iter("ext:rs", options)?
///     .filter_map(Result::ok)
///     .collect();
/// ```
pub fn search_iter(
    query: &str,
    options: SearchOptions,
) -> Result<SearchResultIterator> {
    let raw_results = commands::search::perform_search_internal(query, &options)?;
    Ok(SearchResultIterator::new(raw_results))
}
```

### Why SearchOptions is Owned, Not Borrowed
Taking ownership avoids lifetime parameters in the return type. Since `SearchOptions` is cheap to construct and users typically create it inline, this is ergonomic:
```rust
// Clean API - no lifetime annotations
let iter = search_iter("query", SearchOptions::default())?;

// vs requiring a reference (would need lifetime)
let options = SearchOptions::default();
let iter = search_iter("query", &options)?;  // iter borrows options
// options must outlive iter
```

### Usage Patterns

#### Basic Iteration
```rust
use rdump::{search_iter, SearchOptions};

let results = search_iter("ext:rs & func:main", SearchOptions::default())?;
for result in results {
    let result = result?;
    println!("{}: {} matches", result.path.display(), result.matches.len());
}
```

#### Early Termination (Memory Efficient)
```rust
// Find first 10 matches only - stops iteration early
let first_ten: Vec<_> = search_iter("ext:rs", options)?
    .take(10)
    .collect::<Result<Vec<_>, _>>()?;
```

#### Skip Errors (Graceful Degradation)
```rust
// Skip files that can't be read
let results: Vec<_> = search_iter("ext:rs", options)?
    .filter_map(Result::ok)
    .collect();
```

#### Count Without Loading Content
```rust
// Count matches without loading all content into memory
let count = search_iter("ext:rs", options)?
    .filter_map(Result::ok)
    .count();
```

#### With Custom Options
```rust
use std::path::PathBuf;
use rdump::{search_iter, SearchOptions, SqlDialect};

let results = search_iter(
    "lang:sql & select",
    SearchOptions {
        root: PathBuf::from("/projects/myapp"),
        presets: vec!["default".to_string()],
        no_ignore: false,
        hidden: false,
        max_depth: Some(10),
        sql_dialect: Some(SqlDialect::Postgresql),
    },
)?;
```

### Complete Test Cases

**Test Location:** `tests/library_api.rs`

```rust
use rdump::{search_iter, SearchOptions};
use std::fs;
use tempfile::tempdir;

#[test]
fn test_search_iter_basic() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results: Vec<_> = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
}

#[test]
fn test_search_iter_early_termination() {
    let dir = tempdir().unwrap();

    // Create 10 files
    for i in 0..10 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    // Only take first 3
    let results: Vec<_> = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .take(3)
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 3);
}

#[test]
fn test_search_iter_invalid_query() {
    let dir = tempdir().unwrap();

    let result = search_iter("invalid::: query syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_nonexistent_root() {
    let result = search_iter("ext:rs", SearchOptions {
        root: std::path::PathBuf::from("/nonexistent/path"),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_unknown_preset() {
    let dir = tempdir().unwrap();

    let result = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["nonexistent_preset".to_string()],
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_search_iter_empty_query() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    // Empty query should match based on presets
    let results: Vec<_> = search_iter("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string()],
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
}

#[test]
fn test_search_iter_skip_errors() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete file after creating iterator
    fs::remove_file(&file).unwrap();

    // Skip errors gracefully
    let results: Vec<_> = iter.filter_map(Result::ok).collect();
    assert_eq!(results.len(), 0);
}

#[test]
fn test_search_iter_with_func_query() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn my_function() {\n    println!(\"hello\");\n}").unwrap();

    let results: Vec<_> = search_iter("func:my_function", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .collect::<Result<Vec<_>, _>>()
    .unwrap();

    assert_eq!(results.len(), 1);
    assert!(!results[0].matches.is_empty());
    assert!(results[0].matches[0].text.contains("my_function"));
}

#[test]
fn test_search_iter_count_only() {
    let dir = tempdir().unwrap();

    for i in 0..5 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    let count = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .unwrap()
    .filter_map(Result::ok)
    .count();

    assert_eq!(count, 5);
}
```

### Technical Notes

**Error Propagation:**
- Query parsing errors are returned immediately from `search_iter()`
- File reading errors are returned per-item from the iterator
- This allows users to handle setup errors differently from runtime errors

**Memory Efficiency:**
- Only one file's content is loaded at a time
- Previous results are dropped as iteration proceeds
- Ideal for processing large codebases

- [Source: docs/architecture.md#test-strategy]

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation provides the recommended public API for streaming search with comprehensive rustdoc documentation. The function is ergonomic (owned SearchOptions), well-documented, and delegates cleanly to the internal search function.

**Implementation Highlights:**
- Clean two-line implementation delegates to `perform_search_internal`
- Owned `SearchOptions` avoids lifetime complexity in return type
- Comprehensive rustdoc with Arguments, Returns, Errors, and 3 Examples
- Clear guidance on when to use vs `search()`
- Error propagation: setup errors returned immediately, per-file errors from iterator

**Code Location:** `rdump/src/lib.rs:460-513`

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ Proper error propagation, no unwrap()
- Project Structure: ✓ Public function in crate root
- Testing Strategy: ✓ All 8 tests pass
- All ACs Met: ✓ All 11 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

- [x] Public function in rdump crate root (line 510)
- [x] Takes &str query and owned SearchOptions (line 510)
- [x] Returns Result<SearchResultIterator> (line 510)
- [x] Invalid query returns Err immediately (via perform_search_internal)
- [x] Nonexistent root returns Err immediately
- [x] Unknown preset returns Err immediately
- [x] Empty query matches all files based on presets (documented lines 467-468)
- [x] Rustdoc with full description (lines 460-509)
- [x] Documents all error conditions (lines 474-478)
- [x] Multiple examples (lines 481-509)
- [x] Explains when to use vs search() (lines 462-464)

### Security Review

No security concerns - delegates to validated internal function.

### Performance Considerations

**Efficient implementation:**
- Delegates directly to `perform_search_internal`
- No additional overhead
- Streaming design loads files lazily

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.9-create-search-iter-function.yml

### Recommended Status

✓ Ready for Done

All 11 acceptance criteria have been met, all 8 tests pass, and the implementation provides a well-documented public API for streaming search.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 1.0 | Added public search_iter API with docs and tests | Dev Agent |
