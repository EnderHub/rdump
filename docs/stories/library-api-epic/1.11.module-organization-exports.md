# Story 1.11: Module Organization and Exports

## Status
Draft

## Story
**As a** library user,
**I want** all public types and functions exported from `lib.rs` with proper organization,
**so that** I can import everything I need from the crate root with clear, discoverable APIs.

## Acceptance Criteria

**Type Exports:**
1. - [ ] `rdump::SearchOptions` is accessible
2. - [ ] `rdump::SearchResult` is accessible
3. - [ ] `rdump::Match` is accessible
4. - [ ] `rdump::SearchResultIterator` is accessible
5. - [ ] `rdump::SqlDialect` is re-exported

**Function Exports:**
6. - [ ] `rdump::search_iter` is accessible
7. - [ ] `rdump::search` is accessible

**Backward Compatibility:**
8. - [ ] All existing CLI exports unchanged (`SearchArgs`, etc.)
9. - [ ] No breaking changes to existing public API
10. - [ ] Existing `perform_search()` still accessible if previously public

**Documentation:**
11. - [ ] Module-level docs explain library vs CLI usage
12. - [ ] Each export has rustdoc

**Verification:**
13. - [ ] Test file verifies all imports work
14. - [ ] `cargo doc` generates clean docs with all public items

## Tasks / Subtasks

- [ ] Organize exports in `src/lib.rs` (AC: 1-7)
  - [ ] Create clear section for Library API Types
  - [ ] Create clear section for Library API Functions
  - [ ] Re-export SqlDialect
- [ ] Preserve CLI exports (AC: 8, 9, 10)
  - [ ] Keep all existing public exports
  - [ ] Add clear section for CLI API
- [ ] Add module-level documentation (AC: 11)
- [ ] Ensure all exports have rustdoc (AC: 12)
- [ ] Create verification test (AC: 13)
- [ ] Run cargo doc to verify (AC: 14)

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 11]

### Complete Implementation

```rust
// At the top of lib.rs, organize exports clearly

// =============================================================================
// Library API Types
// =============================================================================

/// Options for performing a search (library-friendly)
#[derive(Debug, Clone)]
pub struct SearchOptions { /* ... */ }

/// A file that matched the search query
#[derive(Debug, Clone)]
pub struct SearchResult { /* ... */ }

/// A single match within a file
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Match { /* ... */ }

/// Iterator over search results
pub struct SearchResultIterator { /* ... */ }

// =============================================================================
// Library API Functions
// =============================================================================

/// Search for files matching a query (streaming, memory-efficient)
pub fn search_iter(query: &str, options: SearchOptions) -> Result<SearchResultIterator> { /* ... */ }

/// Search for files matching a query (convenience wrapper)
pub fn search(query: &str, options: SearchOptions) -> Result<Vec<SearchResult>> { /* ... */ }

// =============================================================================
// Re-exports for Library Users
// =============================================================================

/// Re-export SqlDialect so users don't need to dig into predicates module
pub use predicates::code_aware::SqlDialect;

// =============================================================================
// CLI Types (existing, unchanged)
// =============================================================================

/// CLI argument struct for search command
#[derive(Debug, Clone, Parser)]
pub struct SearchArgs { /* ... unchanged ... */ }

// Other existing CLI types...
```

### Alternative: Module Structure Organization

Alternatively, organize into submodules:

```rust
// src/lib.rs

// Library API module
mod library_api {
    mod types;
    mod search;

    pub use types::{Match, SearchOptions, SearchResult, SearchResultIterator};
    pub use search::{search, search_iter};
}

// Re-export at crate root for convenience
pub use library_api::{
    search, search_iter,
    Match, SearchOptions, SearchResult, SearchResultIterator,
};

// External type re-export
pub use predicates::code_aware::SqlDialect;

// Keep all existing CLI exports unchanged
pub use args::{SearchArgs, /* other CLI args */};
```

### Prelude Module (Optional Enhancement)

For even more convenient imports:

```rust
// src/lib.rs

/// Convenient imports for library users
pub mod prelude {
    pub use crate::{
        search, search_iter,
        Match, SearchOptions, SearchResult, SearchResultIterator,
        SqlDialect,
    };
}

// Usage:
// use rdump::prelude::*;
```

### Why Re-export SqlDialect?
`SqlDialect` lives in `predicates::code_aware::SqlDialect`. Without re-export, users would need:
```rust
// Without re-export (awkward)
use rdump::SearchOptions;
use rdump::predicates::code_aware::SqlDialect;  // Deep path

// With re-export (clean)
use rdump::{SearchOptions, SqlDialect};
```

### Keeping CLI and Library Separate
The CLI types (`SearchArgs`, etc.) and library types (`SearchOptions`, etc.) are both exported but serve different purposes:
- CLI types: For building command-line tools on top of rdump
- Library types: For embedding search in other Rust programs

Both are valid use cases, so both are exported.

### Complete Test Cases

**Test Location:** `tests/api_exports.rs`

```rust
//! Verification tests for module exports
//!
//! These tests ensure all public types and functions are properly
//! exported and accessible from the crate root.

#[test]
fn test_all_types_importable() {
    // Verify all public types are importable from crate root
    use rdump::{
        Match,
        SearchOptions,
        SearchResult,
        SearchResultIterator,
        SqlDialect,
    };

    // Verify functions
    use rdump::{search, search_iter};

    // Create instances to verify they're fully usable
    let _options = SearchOptions::default();
}

#[test]
fn test_cli_exports_unchanged() {
    // Verify existing CLI exports still work
    use rdump::SearchArgs;
    // Other CLI types...
}

#[test]
fn test_search_options_default() {
    use rdump::SearchOptions;

    let options = SearchOptions::default();
    assert!(options.presets.is_empty());
    assert!(!options.no_ignore);
    assert!(!options.hidden);
    assert!(options.max_depth.is_none());
    assert!(options.sql_dialect.is_none());
}

#[test]
fn test_match_struct_accessible() {
    use rdump::Match;

    let m = Match {
        start_line: 1,
        end_line: 1,
        start_column: 0,
        end_column: 10,
        byte_range: 0..10,
        text: "fn main()".to_string(),
    };

    assert_eq!(m.start_line, 1);
    assert_eq!(m.text, "fn main()");
}

#[test]
fn test_search_result_methods() {
    use rdump::SearchResult;
    use std::path::PathBuf;

    let result = SearchResult {
        path: PathBuf::from("test.rs"),
        matches: vec![],
        content: "fn main() {}".to_string(),
    };

    assert!(result.is_whole_file_match());
}

#[test]
fn test_sql_dialect_variants() {
    use rdump::SqlDialect;

    let _mysql = SqlDialect::Mysql;
    let _postgres = SqlDialect::Postgresql;
    let _sqlite = SqlDialect::Sqlite;
    let _tsql = SqlDialect::Tsql;
}

#[test]
fn test_search_functions_callable() {
    use rdump::{search, search_iter, SearchOptions};
    use std::path::PathBuf;
    use tempfile::tempdir;

    let dir = tempdir().unwrap();

    // Test search_iter is callable
    let _ = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    // Test search is callable
    let _ = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });
}

#[test]
fn test_prelude_import() {
    // If prelude module is implemented
    // use rdump::prelude::*;
    //
    // let _options = SearchOptions::default();
    // let _ = search("ext:rs", _options);
}

#[test]
fn test_no_breaking_changes_to_cli() {
    // Verify that existing CLI code continues to work
    use rdump::SearchArgs;
    use clap::Parser;

    // SearchArgs should still be parseable
    let args = SearchArgs::try_parse_from(["rdump", "ext:rs"]);
    // Just verify it's callable, actual parse depends on CLI impl
}
```

### Verify with cargo doc

Run `cargo doc --no-deps --open` to verify:
- All public types appear in documentation
- Rustdoc renders correctly for each type
- Examples in documentation compile
- Links between types work

### Documentation Verification Checklist

- [ ] `SearchOptions` has complete rustdoc with example
- [ ] `SearchResult` has complete rustdoc with example
- [ ] `Match` has complete rustdoc with example
- [ ] `SearchResultIterator` has complete rustdoc
- [ ] `search_iter` has complete rustdoc with examples
- [ ] `search` has complete rustdoc with examples
- [ ] `SqlDialect` re-export appears in docs
- [ ] Module-level docs explain library usage

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
