# Story 1.4: Create perform_search_internal Function

## Status
Draft

## Story
**As a** library maintainer,
**I want** to extract core search logic into a new function that accepts `SearchOptions`,
**so that** both CLI and library paths can share the same search implementation.

## Acceptance Criteria

1. - [ ] `perform_search_internal` accepts `&str` query and `&SearchOptions`
2. - [ ] Returns `Result<Vec<(PathBuf, Vec<Range>)>>`
3. - [ ] Marked `pub(crate)` (internal, not public API)
4. - [ ] `options.root` maps to walker root directory
5. - [ ] `options.presets` maps to preset resolution
6. - [ ] `options.no_ignore` maps to gitignore handling (inverted for walker)
7. - [ ] `options.hidden` maps to hidden file inclusion (inverted for walker)
8. - [ ] `options.max_depth` maps to directory depth limit
9. - [ ] `options.sql_dialect` maps to SQL file parsing
10. - [ ] Existing `perform_search(&SearchArgs)` still works
11. - [ ] Returns identical results for same inputs
12. - [ ] All existing tests pass unchanged
13. - [ ] No `unwrap()` - use `?` for error propagation
14. - [ ] Config loading handles missing file gracefully
15. - [ ] Preset resolution handles unknown presets

## Tasks / Subtasks

- [ ] Create `perform_search_internal` function in `src/commands/search.rs` (AC: 1, 2, 3)
  - [ ] Accept `query: &str` and `options: &SearchOptions`
  - [ ] Return `Result<Vec<(PathBuf, Vec<Range>)>>`
- [ ] Implement parameter mapping (AC: 4, 5, 6, 7, 8, 9)
  - [ ] Map SearchOptions fields to walker configuration
  - [ ] Handle boolean inversions for walker API
- [ ] Implement core search logic
  - [ ] Load configuration from project root
  - [ ] Resolve presets
  - [ ] Build directory walker
  - [ ] Parse query into AST
  - [ ] Build evaluator
  - [ ] Pre-filter pass (metadata predicates)
  - [ ] Main evaluation pass (parallel with rayon)
- [ ] Update existing `perform_search` to use new function (AC: 10, 11)
  - [ ] Convert SearchArgs to SearchOptions
  - [ ] Call perform_search_internal
- [ ] Add SqlDialect conversion if needed
- [ ] Ensure all existing tests pass (AC: 12)
- [ ] Add error handling without unwrap (AC: 13, 14, 15)

## Dev Notes

### Location
- Primary file: `src/commands/search.rs`
- [Source: docs/epics/library-api-epic.md - Story 4]

### Complete Implementation

```rust
use crate::SearchOptions;

/// Internal search implementation accepting library-friendly options
///
/// This is the core search function used by both CLI and library paths.
/// It returns raw results that can be transformed into SearchResult.
pub(crate) fn perform_search_internal(
    query: &str,
    options: &SearchOptions,
) -> Result<Vec<(PathBuf, Vec<Range>)>> {
    // Load configuration from project root
    let config_path = options.root.join(".rdump.toml");
    let config = if config_path.exists() {
        config::load_config(&config_path)?
    } else {
        config::RdumpConfig::default()
    };

    // Resolve presets
    let preset_registry = presets::PresetRegistry::load_default()?;
    let resolved_presets: Vec<_> = options.presets
        .iter()
        .filter_map(|name| preset_registry.get(name))
        .collect();

    // Build directory walker
    let mut walker_builder = WalkBuilder::new(&options.root);
    walker_builder
        .hidden(!options.hidden)
        .git_ignore(!options.no_ignore)
        .git_global(!options.no_ignore)
        .git_exclude(!options.no_ignore);

    if let Some(depth) = options.max_depth {
        walker_builder.max_depth(Some(depth));
    }

    // Get candidate files
    let candidates = get_candidate_files(walker_builder)?;

    // Parse query into AST
    let ast = if query.is_empty() {
        None
    } else {
        Some(parser::parse_query(query)?)
    };

    // Validate AST predicates against available presets
    if let Some(ref ast) = ast {
        validate_ast_predicates(ast, &preset_registry)?;
    }

    // Build evaluator with config and presets
    let evaluator = Evaluator::new(
        ast,
        &config,
        &resolved_presets,
        options.sql_dialect,
    );

    // Pre-filter pass (metadata predicates only - fast)
    let pre_filtered: Vec<_> = candidates
        .into_iter()
        .filter(|path| evaluator.pre_filter(path))
        .collect();

    // Main evaluation pass (content + semantic predicates - parallel)
    let results: Vec<(PathBuf, Vec<Range>)> = pre_filtered
        .into_par_iter()
        .filter_map(|path| {
            match evaluator.evaluate(&path) {
                Ok(MatchResult::Boolean(true)) => Some((path, vec![])),
                Ok(MatchResult::Hunks(ranges)) if !ranges.is_empty() => {
                    Some((path, ranges))
                }
                Ok(_) => None,
                Err(e) => {
                    // For library path, we should collect errors instead
                    // For now, maintain CLI behavior
                    eprintln!("Error evaluating {}: {}", path.display(), e);
                    None
                }
            }
        })
        .collect();

    Ok(results)
}

/// Existing perform_search for backward compatibility
///
/// This wrapper maintains the existing CLI API while using the new internal function.
pub fn perform_search(args: &SearchArgs) -> Result<Vec<(PathBuf, Vec<Range>)>> {
    let options = SearchOptions {
        root: args.root.clone(),
        presets: args.preset.clone(),
        no_ignore: args.no_ignore,
        hidden: args.hidden,
        max_depth: args.max_depth,
        sql_dialect: args.dialect.map(Into::into),
    };
    perform_search_internal(
        args.query.as_deref().unwrap_or(""),
        &options,
    )
}
```

### SqlDialect Conversion

If `SqlDialectFlag` and `SqlDialect` are different types, add this conversion:

```rust
impl From<SqlDialectFlag> for SqlDialect {
    fn from(flag: SqlDialectFlag) -> Self {
        match flag {
            SqlDialectFlag::Postgres => SqlDialect::Postgres,
            SqlDialectFlag::Mysql => SqlDialect::Mysql,
            SqlDialectFlag::Sqlite => SqlDialect::Sqlite,
            SqlDialectFlag::Tsql => SqlDialect::Tsql,
            SqlDialectFlag::Plpgsql => SqlDialect::Plpgsql,
        }
    }
}
```

### Why `pub(crate)` visibility?
The function returns raw `(PathBuf, Vec<Range>)` tuples with tree-sitter `Range` types. We don't want to expose tree-sitter internals in the public API. The public `search_iter()` and `search()` functions wrap this and convert to `SearchResult`.

### Performance Preservation
- Pre-filter pass runs single-threaded (metadata only, fast)
- Main evaluation uses `into_par_iter()` for rayon parallelism
- This matches existing CLI performance characteristics

### Error Handling Note
The `eprintln!` in the evaluation pass is CLI behavior. For the library path, errors should be collected or returned. This will be addressed in Story 8 (edge cases).

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Never use `unwrap()` on user data - always handle errors
- Predicates must be `Send + Sync` - required for parallel evaluation

### Testing

**Test Location:** `tests/` directory

**Test Cases:**
- Backward compatibility with existing SearchArgs
- Identical results for same inputs
- All existing CLI tests pass
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_perform_search_internal_basic() {
        let options = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let results = perform_search_internal("ext:rs", &options);
        assert!(results.is_ok());
    }

    #[test]
    fn test_perform_search_internal_empty_query() {
        let options = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        // Empty query should match all files
        let results = perform_search_internal("", &options);
        assert!(results.is_ok());
    }

    #[test]
    fn test_perform_search_internal_with_max_depth() {
        let options = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: Some(1),
            sql_dialect: None,
        };

        let results = perform_search_internal("ext:rs", &options);
        assert!(results.is_ok());

        // All results should be at depth <= 1
        for (path, _) in results.unwrap() {
            let depth = path.strip_prefix(".").unwrap().components().count();
            assert!(depth <= 1, "File {:?} exceeds max depth", path);
        }
    }

    #[test]
    fn test_perform_search_backward_compatibility() {
        // Create equivalent SearchArgs and SearchOptions
        let args = SearchArgs {
            query: Some("ext:rs".to_string()),
            root: PathBuf::from("."),
            preset: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            dialect: None,
            // ... other CLI-specific fields
        };

        let options = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let results_old = perform_search(&args);
        let results_new = perform_search_internal("ext:rs", &options);

        // Both should succeed
        assert!(results_old.is_ok());
        assert!(results_new.is_ok());

        // Results should be identical
        let old = results_old.unwrap();
        let new = results_new.unwrap();
        assert_eq!(old.len(), new.len());
    }

    #[test]
    fn test_perform_search_internal_with_presets() {
        let options = SearchOptions {
            root: PathBuf::from("."),
            presets: vec!["rust".to_string()],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let results = perform_search_internal("fn", &options);
        assert!(results.is_ok());
    }

    #[test]
    fn test_perform_search_internal_hidden_files() {
        let options_no_hidden = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let options_with_hidden = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: true,
            max_depth: None,
            sql_dialect: None,
        };

        let results_no_hidden = perform_search_internal("ext:rs", &options_no_hidden).unwrap();
        let results_with_hidden = perform_search_internal("ext:rs", &options_with_hidden).unwrap();

        // With hidden files enabled, we should have >= results
        assert!(results_with_hidden.len() >= results_no_hidden.len());
    }

    #[test]
    fn test_perform_search_internal_no_ignore() {
        let options_with_ignore = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let options_no_ignore = SearchOptions {
            root: PathBuf::from("."),
            presets: vec![],
            no_ignore: true,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        let results_with_ignore = perform_search_internal("ext:rs", &options_with_ignore).unwrap();
        let results_no_ignore = perform_search_internal("ext:rs", &options_no_ignore).unwrap();

        // Without gitignore, we may have more results (target/, etc.)
        assert!(results_no_ignore.len() >= results_with_ignore.len());
    }

    #[test]
    fn test_config_loading_missing_file() {
        let options = SearchOptions {
            root: PathBuf::from("/tmp/nonexistent_dir"),
            presets: vec![],
            no_ignore: false,
            hidden: false,
            max_depth: None,
            sql_dialect: None,
        };

        // Should use default config, not panic
        let results = perform_search_internal("ext:rs", &options);
        // Will likely error due to nonexistent dir, but shouldn't panic
        assert!(results.is_err() || results.unwrap().is_empty());
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
