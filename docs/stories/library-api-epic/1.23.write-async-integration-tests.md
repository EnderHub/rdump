# Story 1.23: Write Async Integration Tests

## Status
Draft

## Story
**As a** library maintainer,
**I want** comprehensive integration tests for the async API,
**so that** basic functionality, error handling, and edge cases are verified for async usage.

## Acceptance Criteria

**Basic Tests:**
1. - [ ] `test_search_async_basic` - passes
2. - [ ] `test_search_all_async_basic` - passes
3. - [ ] `test_search_async_empty_results` - passes
4. - [ ] `test_search_all_async_empty_results` - passes

**Stream Behavior:**
5. - [ ] `test_search_async_early_termination` - passes
6. - [ ] `test_search_async_drop_stream` - passes
7. - [ ] `test_search_async_concurrent_processing` - passes

**Error Handling:**
8. - [ ] `test_search_async_error_propagation` - passes
9. - [ ] `test_search_all_async_error_propagation` - passes

**All Tests Pass:**
10. - [ ] `cargo test --features async --test async_api`

## Tasks / Subtasks

- [ ] Create test file `tests/async_api.rs`
- [ ] Add feature gate `#![cfg(feature = "async")]`
- [ ] Write basic functionality tests (AC: 1, 2, 3, 4)
  - [ ] Basic streaming
  - [ ] Collection convenience
  - [ ] Empty results
- [ ] Write stream behavior tests (AC: 5, 6, 7)
  - [ ] Early termination with `.take()`
  - [ ] Stream drop stops producer
  - [ ] Concurrent stream processing
- [ ] Write error handling tests (AC: 8, 9)
- [ ] Verify all tests pass (AC: 10)

## Dev Notes

### Location
- Test file: `tests/async_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 23]

### Running Tests
```bash
cargo test --features async --test async_api
```

### Test Pattern
```rust
#![cfg(feature = "async")]

use anyhow::Result;
use futures::StreamExt;
use rdump::{search_async, search_all_async, SearchOptions};
use std::fs;
use tempfile::tempdir;

#[tokio::test]
async fn test_search_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let mut stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    let mut count = 0;
    while let Some(result) = stream.next().await {
        let result = result?;
        assert!(result.path.extension().unwrap() == "rs");
        count += 1;
    }

    assert_eq!(count, 1);
    Ok(())
}
```

### Key Test Scenarios

**Early Termination:**
```rust
let stream = search_async("ext:rs", options).await?;
let first_five: Vec<_> = stream
    .take(5)
    .collect::<Vec<_>>()
    .await
    .into_iter()
    .collect::<Result<Vec<_>, _>>()?;
```

**Drop Stream:**
```rust
{
    let mut stream = search_async("ext:rs", options).await?;
    let _ = stream.next().await;  // Read one
    // Drop stream - producer should stop
}
// Should complete without hanging
```

### Complete Implementation

#### tests/async_api.rs

```rust
//! Integration tests for async API
//!
//! Run with: cargo test --features async --test async_api

#![cfg(feature = "async")]

use anyhow::Result;
use futures::StreamExt;
use rdump::{search_async, search_all_async, SearchOptions};
use std::fs;
use tempfile::tempdir;

// =============================================================================
// Basic Functionality Tests
// =============================================================================

#[tokio::test]
async fn test_search_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let mut stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    let mut count = 0;
    while let Some(result) = stream.next().await {
        let result = result?;
        assert!(result.path.extension().unwrap() == "rs");
        count += 1;
    }

    assert_eq!(count, 2);
    Ok(())
}

#[tokio::test]
async fn test_search_all_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let results = search_all_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert_eq!(results.len(), 2);
    Ok(())
}

#[tokio::test]
async fn test_search_async_empty_results() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let mut stream = search_async("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert!(stream.next().await.is_none());
    Ok(())
}

#[tokio::test]
async fn test_search_all_async_empty_results() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let results = search_all_async("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert!(results.is_empty());
    Ok(())
}

// =============================================================================
// Stream Behavior Tests
// =============================================================================

#[tokio::test]
async fn test_search_async_early_termination() -> Result<()> {
    let dir = tempdir()?;

    // Create many files
    for i in 0..50 {
        fs::write(dir.path().join(format!("file{}.rs", i)), "fn main() {}")?;
    }

    let stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    // Take only first 5
    let first_five: Vec<_> = stream
        .take(5)
        .collect::<Vec<_>>()
        .await
        .into_iter()
        .collect::<Result<Vec<_>, _>>()?;

    assert_eq!(first_five.len(), 5);
    Ok(())
}

#[tokio::test]
async fn test_search_async_drop_stream() -> Result<()> {
    let dir = tempdir()?;

    for i in 0..100 {
        fs::write(dir.path().join(format!("file{}.rs", i)), "fn main() {}")?;
    }

    {
        let mut stream = search_async("ext:rs", SearchOptions {
            root: dir.path().to_path_buf(),
            ..Default::default()
        }).await?;

        // Read just one
        let _ = stream.next().await;

        // Drop stream - producer should stop
    }

    // Should complete without hanging
    Ok(())
}

#[tokio::test]
async fn test_search_async_collect_pattern() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    // Common pattern: collect stream into vec
    let results: Vec<_> = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })
    .await?
    .collect()
    .await;

    // Results are Result<SearchResult>
    assert_eq!(results.len(), 1);
    assert!(results[0].is_ok());
    Ok(())
}

// =============================================================================
// Error Handling Tests
// =============================================================================

#[tokio::test]
async fn test_search_async_invalid_query() {
    let dir = tempdir().unwrap();

    let result = search_async("invalid((syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await;

    // Should return error immediately (before stream)
    assert!(result.is_err() || {
        // Or first item is error
        let mut stream = result.unwrap();
        matches!(
            futures::executor::block_on(stream.next()),
            Some(Err(_))
        )
    });
}

#[tokio::test]
async fn test_search_async_nonexistent_root() {
    let result = search_async("ext:rs", SearchOptions {
        root: std::path::PathBuf::from("/nonexistent/path"),
        ..Default::default()
    }).await;

    // Error should propagate
    assert!(result.is_err() || {
        let mut stream = result.unwrap();
        matches!(
            futures::executor::block_on(stream.next()),
            Some(Err(_)) | None
        )
    });
}

#[tokio::test]
async fn test_search_async_skip_errors() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("good.rs"), "fn main() {}")?;

    let stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    // Skip errors pattern
    let results: Vec<_> = stream
        .filter_map(|r| async { r.ok() })
        .collect()
        .await;

    assert_eq!(results.len(), 1);
    Ok(())
}

// =============================================================================
// Concurrent Usage Tests
// =============================================================================

#[tokio::test]
async fn test_multiple_concurrent_searches() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("test.py"), "def main(): pass")?;

    let options1 = SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    };
    let options2 = options1.clone();

    // Run two searches concurrently
    let (results1, results2) = tokio::join!(
        search_all_async("ext:rs", options1),
        search_all_async("ext:py", options2),
    );

    assert_eq!(results1?.len(), 1);
    assert_eq!(results2?.len(), 1);
    Ok(())
}

#[tokio::test]
async fn test_search_in_spawn() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let root = dir.path().to_path_buf();

    let handle = tokio::spawn(async move {
        search_all_async("ext:rs", SearchOptions {
            root,
            ..Default::default()
        }).await
    });

    let results = handle.await??;
    assert_eq!(results.len(), 1);
    Ok(())
}

// =============================================================================
// Feature Tests
// =============================================================================

#[tokio::test]
async fn test_search_async_with_function_predicate() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}\nfn helper() {}")?;

    let results = search_all_async("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert_eq!(results.len(), 1);
    assert!(!results[0].is_whole_file_match());
    assert_eq!(results[0].matches.len(), 1);
    Ok(())
}

#[tokio::test]
async fn test_search_async_with_options() -> Result<()> {
    let dir = tempdir()?;

    // Create nested structure
    let sub = dir.path().join("sub");
    fs::create_dir(&sub)?;
    fs::write(dir.path().join("root.rs"), "fn main() {}")?;
    fs::write(sub.join("nested.rs"), "fn main() {}")?;

    // With max_depth: 1
    let results = search_all_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        max_depth: Some(1),
        ..Default::default()
    }).await?;

    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "root.rs");
    Ok(())
}
```

### Testing

**Test Location:** `tests/async_api.rs`

**Test Categories:**
- Basic functionality
- Stream behavior (early termination, drop)
- Error propagation
- Concurrent usage
- Feature integration
- [Source: docs/architecture.md#test-strategy]

**Running Tests:**
```bash
cargo test --features async --test async_api
```

**Why `#[tokio::test]`?**

The async tests need a runtime. `#[tokio::test]` macro:
1. Creates a new runtime for each test
2. Runs test as async
3. Handles panics correctly

**Testing Early Termination:**

We can't directly test that the producer stops, but we can verify:
1. Taking fewer items works
2. Dropping stream doesn't hang
3. Memory doesn't grow unboundedly

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
