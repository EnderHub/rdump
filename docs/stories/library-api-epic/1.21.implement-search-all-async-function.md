# Story 1.21: Implement search_all_async Function

## Status
Done

## Story
**As a** library user in an async application,
**I want** an async convenience function that collects all results,
**so that** I can easily get all results for smaller result sets in async code.

## Acceptance Criteria

**Function Signature:**
1. - [x] Returns `Result<Vec<SearchResult>>`
2. - [x] Takes `&str` query and owned `SearchOptions`
3. - [x] Feature-gated with `#[cfg(feature = "async")]`

**Behavior:**
4. - [x] Collects all stream results
5. - [x] First error causes `Err` return
6. - [x] Empty result set returns `Ok(vec![])`

**Documentation:**
7. - [x] Full rustdoc with examples
8. - [x] Performance warning for large results
9. - [x] Cross-reference to `search_async`

**Testing:**
10. - [x] Basic collection works
11. - [x] Error propagation works
12. - [x] Empty results handled

## Tasks / Subtasks

- [x] Implement `search_all_async` in `src/async_api.rs` (AC: 1, 2, 3)
  - [x] Call `search_async`
  - [x] Collect stream into Vec
- [x] Implement collection behavior (AC: 4, 5, 6)
  - [x] Use `stream.collect::<Vec<_>>().await`
  - [x] Convert to Result<Vec<_>>
- [x] Add rustdoc documentation (AC: 7, 8, 9)
  - [x] Usage example
  - [x] Performance note
  - [x] Reference to search_async
- [x] Write tests (AC: 10, 11, 12)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Implemented `search_all_async` in `rdump/src/async_api.rs` (feature-gated) collecting from `search_async`; rustdoc includes examples, performance warning, and cross-reference.
  - Exported via `lib.rs`; added async tests in `rdump/tests/async_api.rs` for basic collection, empty results, and error propagation.
  - Verified with `cargo test --features async --offline --test async_api` and full async test run.
- File List:
  - rdump/src/async_api.rs
  - rdump/src/lib.rs
  - rdump/tests/async_api.rs

## Dev Notes

### Location
- Primary file: `src/async_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 21]

### Implementation
```rust
pub async fn search_all_async(
    query: &str,
    options: SearchOptions,
) -> Result<Vec<SearchResult>> {
    use futures::StreamExt;

    let stream = search_async(query, options).await?;

    // Collect all results, failing on first error
    stream.collect::<Vec<_>>().await
        .into_iter()
        .collect()
}
```

### Example Usage
```rust
use rdump::{search_all_async, SearchOptions};
use std::path::PathBuf;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let results = search_all_async(
        "ext:rs & func:main",
        SearchOptions {
            root: PathBuf::from("./src"),
            ..Default::default()
        }
    ).await?;

    println!("Found {} files with main function", results.len());

    for result in &results {
        println!("  {} ({} bytes)",
            result.path.display(),
            result.content.len()
        );
    }

    Ok(())
}
```

### Performance Note
This loads all matching file contents into memory. For repositories with many matches, consider using `search_async` with streaming.

### Complete Implementation

#### src/async_api.rs (continued)

```rust
/// Search for files matching a query (async, convenience)
///
/// Collects all results into a Vec. Use [`search_async`] for large
/// result sets to avoid loading all content into memory.
///
/// # Arguments
///
/// * `query` - An RQL query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// A vector of all matching files with their content loaded.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - Any file in the results fails to read
///
/// # Example
///
/// ```rust
/// use rdump::{search_all_async, SearchOptions};
/// use std::path::PathBuf;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let results = search_all_async(
///         "ext:rs & func:main",
///         SearchOptions {
///             root: PathBuf::from("./src"),
///             ..Default::default()
///         }
///     ).await?;
///
///     println!("Found {} files with main function", results.len());
///
///     for result in &results {
///         println!("  {} ({} bytes)",
///             result.path.display(),
///             result.content.len()
///         );
///     }
///
///     Ok(())
/// }
/// ```
///
/// # Performance Note
///
/// This loads all matching file contents into memory. For repositories
/// with many matches, consider using [`search_async`] with streaming:
///
/// ```rust
/// # use rdump::{search_async, SearchOptions};
/// # use futures::StreamExt;
/// # async fn example() -> anyhow::Result<()> {
/// let mut stream = search_async("ext:rs", SearchOptions::default()).await?;
///
/// while let Some(result) = stream.next().await {
///     process(result?);
/// }
/// # fn process(_: rdump::SearchResult) {}
/// # Ok(())
/// # }
/// ```
pub async fn search_all_async(
    query: &str,
    options: SearchOptions,
) -> Result<Vec<SearchResult>> {
    use futures::StreamExt;

    let stream = search_async(query, options).await?;

    // Collect all results, failing on first error
    stream.collect::<Vec<_>>().await
        .into_iter()
        .collect()
}
```

### Testing

**Test Location:** `tests/async_api.rs`

**Test Cases:**
- Basic collection
- Empty results
- Error propagation
- [Source: docs/architecture.md#test-strategy]

**Test Code:**
```rust
#[tokio::test]
async fn test_search_all_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let results = search_all_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert_eq!(results.len(), 2);
    Ok(())
}

#[tokio::test]
async fn test_search_all_async_empty_results() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let results = search_all_async("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert!(results.is_empty());
    Ok(())
}

#[tokio::test]
async fn test_multiple_concurrent_searches() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("test.py"), "def main(): pass")?;

    let options1 = SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    };
    let options2 = options1.clone();

    // Run two searches concurrently
    let (results1, results2) = tokio::join!(
        search_all_async("ext:rs", options1),
        search_all_async("ext:py", options2),
    );

    assert_eq!(results1?.len(), 1);
    assert_eq!(results2?.len(), 1);
    Ok(())
}
```

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Clean convenience function that wraps search_async for collecting all results. Well-documented with performance warnings and cross-references.

**Implementation Highlights:**
- Function signature returns `Result<Vec<SearchResult>>` (line 115)
- Collects stream with `stream.collect::<Vec<_>>().await.into_iter().collect()` (line 119)
- First error causes Err return via iterator collect
- Full rustdoc with # Arguments, # Returns, # Errors, # Examples, # Performance Note
- Cross-reference to `search_async` (lines 79-81, 113-114)

**Code Locations:**
- `rdump/src/async_api.rs` (lines 77-120)
- `rdump/src/lib.rs` (line 205)
- `rdump/tests/async_api.rs` (lines 72-122)

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ Clean async/await patterns
- Project Structure: ✓ Properly feature-gated
- Testing Strategy: ✓ All 3 test scenarios covered
- All ACs Met: ✓ All 12 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

**Function Signature (3/3):**
- [x] Returns `Result<Vec<SearchResult>>` (line 115)
- [x] Takes `&str` query and owned `SearchOptions` (line 115)
- [x] Feature-gated with `#[cfg(feature = "async")]` (lib.rs line 205)

**Behavior (3/3):**
- [x] Collects all stream results (line 119)
- [x] First error causes `Err` return (iterator collect pattern)
- [x] Empty result set returns `Ok(vec![])` (verified by test)

**Documentation (3/3):**
- [x] Full rustdoc with examples (lines 77-114)
- [x] Performance warning for large results (lines 112-114)
- [x] Cross-reference to `search_async` (lines 79-81)

**Testing (3/3):**
- [x] Basic collection works (`test_search_all_async_collects`)
- [x] Error propagation works (`test_search_all_async_error`)
- [x] Empty results handled (`test_search_all_async_empty`)

### Test Results

| Test | Result |
|------|--------|
| `test_search_all_async_collects` | PASS |
| `test_search_all_async_empty` | PASS |
| `test_search_all_async_error` | PASS |
| Doc test (search_all_async) | PASS |

Total: 4 tests pass (3 integration + 1 doc test)

### Security Review

No security concerns - standard async collection pattern.

### Performance Considerations

**Memory usage:**
- Collects all results into memory
- Performance warning properly documented
- Users directed to search_async for large result sets

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.21-implement-search-all-async-function.yml

### Recommended Status

✓ Ready for Done

All 12 acceptance criteria have been met. The search_all_async function provides a clean convenience wrapper for collecting all results in async applications.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 0.2 | Added async collection helper and tests | Dev Agent |
| 2025-11-21 | 1.0 | QA Review completed - all 12 ACs verified | Quinn (QA) |
