# Story 1.21: Implement search_all_async Function

## Status
Draft

## Story
**As a** library user in an async application,
**I want** an async convenience function that collects all results,
**so that** I can easily get all results for smaller result sets in async code.

## Acceptance Criteria

**Function Signature:**
1. - [ ] Returns `Result<Vec<SearchResult>>`
2. - [ ] Takes `&str` query and owned `SearchOptions`
3. - [ ] Feature-gated with `#[cfg(feature = "async")]`

**Behavior:**
4. - [ ] Collects all stream results
5. - [ ] First error causes `Err` return
6. - [ ] Empty result set returns `Ok(vec![])`

**Documentation:**
7. - [ ] Full rustdoc with examples
8. - [ ] Performance warning for large results
9. - [ ] Cross-reference to `search_async`

**Testing:**
10. - [ ] Basic collection works
11. - [ ] Error propagation works
12. - [ ] Empty results handled

## Tasks / Subtasks

- [ ] Implement `search_all_async` in `src/async_api.rs` (AC: 1, 2, 3)
  - [ ] Call `search_async`
  - [ ] Collect stream into Vec
- [ ] Implement collection behavior (AC: 4, 5, 6)
  - [ ] Use `stream.collect::<Vec<_>>().await`
  - [ ] Convert to Result<Vec<_>>
- [ ] Add rustdoc documentation (AC: 7, 8, 9)
  - [ ] Usage example
  - [ ] Performance note
  - [ ] Reference to search_async
- [ ] Write tests (AC: 10, 11, 12)

## Dev Notes

### Location
- Primary file: `src/async_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 21]

### Implementation
```rust
pub async fn search_all_async(
    query: &str,
    options: SearchOptions,
) -> Result<Vec<SearchResult>> {
    use futures::StreamExt;

    let stream = search_async(query, options).await?;

    // Collect all results, failing on first error
    stream.collect::<Vec<_>>().await
        .into_iter()
        .collect()
}
```

### Example Usage
```rust
use rdump::{search_all_async, SearchOptions};
use std::path::PathBuf;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let results = search_all_async(
        "ext:rs & func:main",
        SearchOptions {
            root: PathBuf::from("./src"),
            ..Default::default()
        }
    ).await?;

    println!("Found {} files with main function", results.len());

    for result in &results {
        println!("  {} ({} bytes)",
            result.path.display(),
            result.content.len()
        );
    }

    Ok(())
}
```

### Performance Note
This loads all matching file contents into memory. For repositories with many matches, consider using `search_async` with streaming.

### Complete Implementation

#### src/async_api.rs (continued)

```rust
/// Search for files matching a query (async, convenience)
///
/// Collects all results into a Vec. Use [`search_async`] for large
/// result sets to avoid loading all content into memory.
///
/// # Arguments
///
/// * `query` - An RQL query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// A vector of all matching files with their content loaded.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - Any file in the results fails to read
///
/// # Example
///
/// ```rust
/// use rdump::{search_all_async, SearchOptions};
/// use std::path::PathBuf;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let results = search_all_async(
///         "ext:rs & func:main",
///         SearchOptions {
///             root: PathBuf::from("./src"),
///             ..Default::default()
///         }
///     ).await?;
///
///     println!("Found {} files with main function", results.len());
///
///     for result in &results {
///         println!("  {} ({} bytes)",
///             result.path.display(),
///             result.content.len()
///         );
///     }
///
///     Ok(())
/// }
/// ```
///
/// # Performance Note
///
/// This loads all matching file contents into memory. For repositories
/// with many matches, consider using [`search_async`] with streaming:
///
/// ```rust
/// # use rdump::{search_async, SearchOptions};
/// # use futures::StreamExt;
/// # async fn example() -> anyhow::Result<()> {
/// let mut stream = search_async("ext:rs", SearchOptions::default()).await?;
///
/// while let Some(result) = stream.next().await {
///     process(result?);
/// }
/// # fn process(_: rdump::SearchResult) {}
/// # Ok(())
/// # }
/// ```
pub async fn search_all_async(
    query: &str,
    options: SearchOptions,
) -> Result<Vec<SearchResult>> {
    use futures::StreamExt;

    let stream = search_async(query, options).await?;

    // Collect all results, failing on first error
    stream.collect::<Vec<_>>().await
        .into_iter()
        .collect()
}
```

### Testing

**Test Location:** `tests/async_api.rs`

**Test Cases:**
- Basic collection
- Empty results
- Error propagation
- [Source: docs/architecture.md#test-strategy]

**Test Code:**
```rust
#[tokio::test]
async fn test_search_all_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let results = search_all_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert_eq!(results.len(), 2);
    Ok(())
}

#[tokio::test]
async fn test_search_all_async_empty_results() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;

    let results = search_all_async("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    assert!(results.is_empty());
    Ok(())
}

#[tokio::test]
async fn test_multiple_concurrent_searches() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("test.py"), "def main(): pass")?;

    let options1 = SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    };
    let options2 = options1.clone();

    // Run two searches concurrently
    let (results1, results2) = tokio::join!(
        search_all_async("ext:rs", options1),
        search_all_async("ext:py", options2),
    );

    assert_eq!(results1?.len(), 1);
    assert_eq!(results2?.len(), 1);
    Ok(())
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
