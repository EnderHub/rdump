# Story 1.12: Verify Thread Safety

## Status
Draft

## Story
**As a** library user,
**I want** all public types to be `Send + Sync`,
**so that** I can safely use search results in multi-threaded contexts and async runtimes.

## Acceptance Criteria

**Compile-Time Checks:**
1. - [ ] `SearchOptions` implements `Send`
2. - [ ] `SearchOptions` implements `Sync`
3. - [ ] `SearchResult` implements `Send`
4. - [ ] `SearchResult` implements `Sync`
5. - [ ] `Match` implements `Send`
6. - [ ] `Match` implements `Sync`
7. - [ ] `SearchResultIterator` implements `Send`

**Runtime Tests:**
8. - [ ] `SearchOptions` can be moved to another thread
9. - [ ] `SearchResult` can be moved to another thread
10. - [ ] `SearchResult` can be shared via `Arc`
11. - [ ] `SearchResultIterator` can be moved to another thread
12. - [ ] Results can be processed in parallel with rayon

**All Tests Pass:**
13. - [ ] `cargo test --test thread_safety`

## Tasks / Subtasks

- [ ] Create thread safety test file `tests/thread_safety.rs`
- [ ] Add compile-time assertions for Send (AC: 1, 3, 5, 7)
  - [ ] Use `fn assert_send<T: Send>() {}`
- [ ] Add compile-time assertions for Sync (AC: 2, 4, 6)
  - [ ] Use `fn assert_sync<T: Sync>() {}`
- [ ] Add runtime tests for thread movement (AC: 8, 9, 11)
  - [ ] Spawn threads that move types
- [ ] Add Arc sharing test (AC: 10)
- [ ] Add rayon parallel processing test (AC: 12)
- [ ] Verify all tests pass (AC: 13)

## Dev Notes

### Location
- Test file: `tests/thread_safety.rs`
- [Source: docs/epics/library-api-epic.md - Story 12]

### Complete Implementation

```rust
//! Thread safety tests for library API types
//!
//! These tests verify that all public types can be safely sent between
//! threads and shared across threads. This is important for:
//! - Async runtimes (tokio, async-std)
//! - Parallel processing with rayon
//! - Multi-threaded applications

use rdump::{Match, SearchOptions, SearchResult, SearchResultIterator};

/// Compile-time assertions for Send trait
#[test]
fn test_types_are_send() {
    fn assert_send<T: Send>() {}

    assert_send::<SearchOptions>();
    assert_send::<SearchResult>();
    assert_send::<Match>();
    assert_send::<SearchResultIterator>();
}

/// Compile-time assertions for Sync trait
#[test]
fn test_types_are_sync() {
    fn assert_sync<T: Sync>() {}

    assert_sync::<SearchOptions>();
    assert_sync::<SearchResult>();
    assert_sync::<Match>();
    // Note: SearchResultIterator may not be Sync (interior mutability)
    // That's okay - iterators are typically used from one thread
}

/// Verify SearchOptions can be cloned and sent to another thread
#[test]
fn test_search_options_across_threads() {
    use std::thread;

    let options = SearchOptions {
        root: std::path::PathBuf::from("/tmp"),
        presets: vec!["rust".to_string()],
        no_ignore: true,
        hidden: false,
        max_depth: Some(5),
        sql_dialect: None,
    };

    let handle = thread::spawn(move || {
        // Use options in another thread
        assert_eq!(options.presets.len(), 1);
        assert_eq!(options.max_depth, Some(5));
        options
    });

    let returned = handle.join().unwrap();
    assert_eq!(returned.root, std::path::PathBuf::from("/tmp"));
}

/// Verify SearchResult can be sent to another thread
#[test]
fn test_search_result_across_threads() {
    use std::thread;

    let result = SearchResult {
        path: std::path::PathBuf::from("test.rs"),
        matches: vec![Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 10,
            byte_range: 0..10,
            text: "fn main()".to_string(),
        }],
        content: "fn main() {}".to_string(),
    };

    let handle = thread::spawn(move || {
        assert_eq!(result.matches.len(), 1);
        assert_eq!(result.matches[0].start_line, 1);
        result
    });

    let returned = handle.join().unwrap();
    assert_eq!(returned.path.to_str().unwrap(), "test.rs");
}

/// Verify results can be shared via Arc
#[test]
fn test_results_with_arc() {
    use std::sync::Arc;
    use std::thread;

    let result = Arc::new(SearchResult {
        path: std::path::PathBuf::from("shared.rs"),
        matches: vec![],
        content: "// shared content".to_string(),
    });

    let mut handles = vec![];

    for i in 0..3 {
        let result_clone = Arc::clone(&result);
        let handle = thread::spawn(move || {
            // Multiple threads can read the result
            assert_eq!(result_clone.path.to_str().unwrap(), "shared.rs");
            i
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }
}

/// Verify iterator can be moved to another thread
#[test]
fn test_iterator_across_threads() {
    use std::thread;
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search_iter, SearchOptions};

    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Move iterator to another thread for processing
    let handle = thread::spawn(move || {
        let results: Vec<_> = iter.filter_map(Result::ok).collect();
        results.len()
    });

    let count = handle.join().unwrap();
    assert_eq!(count, 1);
}

/// Verify parallel processing of results with rayon
#[test]
fn test_parallel_result_processing() {
    use rayon::prelude::*;
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search, SearchOptions};

    let dir = tempdir().unwrap();
    for i in 0..5 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Process results in parallel with rayon
    let paths: Vec<_> = results
        .par_iter()
        .map(|r| r.path.to_string_lossy().to_string())
        .collect();

    assert_eq!(paths.len(), 5);
}
```

### Additional Thread Safety Test Cases

```rust
/// Test Match struct across threads
#[test]
fn test_match_across_threads() {
    use std::thread;

    let m = Match {
        start_line: 10,
        end_line: 15,
        start_column: 4,
        end_column: 20,
        byte_range: 100..200,
        text: "fn example() {}".to_string(),
    };

    let handle = thread::spawn(move || {
        assert_eq!(m.line_count(), 6);
        assert!(m.is_multiline());
        m
    });

    let returned = handle.join().unwrap();
    assert_eq!(returned.text, "fn example() {}");
}

/// Test multiple results processed in parallel
#[test]
fn test_parallel_match_extraction() {
    use rayon::prelude::*;
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search, SearchOptions};

    let dir = tempdir().unwrap();
    for i in 0..10 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!(
            "fn func{}() {{\n    println!(\"hello {}\");\n}}",
            i, i
        )).unwrap();
    }

    let results = search("func:", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Extract all function texts in parallel
    let function_texts: Vec<_> = results
        .par_iter()
        .flat_map(|r| r.matches.par_iter())
        .map(|m| m.text.clone())
        .collect();

    assert_eq!(function_texts.len(), 10);
}

/// Test thread pool processing
#[test]
fn test_thread_pool_processing() {
    use std::sync::mpsc;
    use std::thread;
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search_iter, SearchOptions};

    let dir = tempdir().unwrap();
    for i in 0..5 {
        let file = dir.path().join(format!("file{}.rs", i));
        fs::write(&file, format!("fn func{}() {{}}", i)).unwrap();
    }

    let (tx, rx) = mpsc::channel();

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Process in separate thread and send results back
    let handle = thread::spawn(move || {
        for result in iter {
            if let Ok(r) = result {
                tx.send(r.path.to_string_lossy().to_string()).unwrap();
            }
        }
    });

    handle.join().unwrap();

    let paths: Vec<_> = rx.iter().collect();
    assert_eq!(paths.len(), 5);
}

/// Test async runtime compatibility (tokio)
#[tokio::test]
async fn test_tokio_spawn_compatibility() {
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search, SearchOptions};

    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let root = dir.path().to_path_buf();

    // Spawn blocking search in tokio
    let results = tokio::task::spawn_blocking(move || {
        search("ext:rs", SearchOptions {
            root,
            ..Default::default()
        })
    })
    .await
    .unwrap()
    .unwrap();

    assert_eq!(results.len(), 1);
}

/// Test results can be sent through channels
#[test]
fn test_channel_sending() {
    use std::sync::mpsc;
    use tempfile::tempdir;
    use std::fs;
    use rdump::{search, SearchOptions, SearchResult};

    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let (tx, rx) = mpsc::channel::<SearchResult>();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    for result in results {
        tx.send(result).unwrap();
    }
    drop(tx);

    let received: Vec<_> = rx.iter().collect();
    assert_eq!(received.len(), 1);
}
```

### Why Send + Sync Matters
- **Send**: Type can be transferred to another thread (ownership moves)
- **Sync**: Type can be shared between threads via reference (`&T` is Send)

For async code:
```rust
// This requires SearchResult: Send
tokio::spawn(async move {
    let result = get_result().await;
    process(result);  // result moved here
});
```

For parallel processing:
```rust
// This requires SearchResult: Sync
results.par_iter().for_each(|result| {
    // Shared reference across threads
});
```

### Why SearchResultIterator Might Not Be Sync
Iterators typically have interior mutability (they track current position). That's fine because you usually consume an iterator from one thread. It still needs to be `Send` so you can move it to a worker thread.

### Automatic Trait Implementation
Rust automatically implements `Send` and `Sync` for types whose fields are all `Send`/`Sync`. Since our structs use:
- `PathBuf` (Send + Sync)
- `String` (Send + Sync)
- `Vec<T>` where T: Send + Sync
- `Option<T>` where T: Send + Sync
- `usize` (Send + Sync)
- `Range<usize>` (Send + Sync)

All our types automatically get `Send + Sync`. The tests verify this is true.

### Test Dependencies

Add to `Cargo.toml` for thread safety tests:
```toml
[dev-dependencies]
rayon = "1.7"
tokio = { version = "1", features = ["full", "test-util"] }
tempfile = "3"
```

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
