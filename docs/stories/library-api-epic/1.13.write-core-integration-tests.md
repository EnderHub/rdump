# Story 1.13: Write Core Integration Tests

## Status
Done

## Story
**As a** library maintainer,
**I want** comprehensive integration tests for basic library functionality,
**so that** the public API is verified to work correctly end-to-end with real file system operations.

## Acceptance Criteria

**Test Coverage:**
1. - [x] `test_basic_extension_search` - passes
2. - [x] `test_search_with_no_results` - passes
3. - [x] `test_search_nonexistent_root` - passes
4. - [x] `test_invalid_query_syntax` - passes
5. - [x] `test_function_predicate` - passes
6. - [x] `test_function_predicate_multiple_matches` - passes
7. - [x] `test_and_query` - passes
8. - [x] `test_or_query` - passes
9. - [x] `test_not_query` - passes
10. - [x] `test_complex_compound_query` - passes
11. - [x] `test_whole_file_match` - passes
12. - [x] `test_whole_file_match_content_available` - passes
13. - [x] `test_match_line_numbers_are_one_indexed` - passes
14. - [x] `test_match_multiline` - passes
15. - [x] `test_match_byte_range` - passes
16. - [x] `test_matched_lines_helper` - passes
17. - [x] `test_match_count_helper` - passes
18. - [x] `test_empty_query_with_preset` - passes

**Test Quality:**
19. - [x] All tests use `tempdir()` for isolation
20. - [x] Tests clean up automatically
21. - [x] Tests are deterministic (no timing dependencies)
22. - [x] Tests have clear assertions with good error messages

## Tasks / Subtasks

- [x] Create test file `tests/library_api.rs`
- [x] Create test fixtures
  - [x] `create_rust_fixtures()` - sample Rust files
  - [x] `create_multi_lang_fixtures()` - multiple language files
- [x] Write basic search tests (AC: 1, 2, 3, 4)
- [x] Write semantic search tests (AC: 5, 6)
- [x] Write compound query tests (AC: 7, 8, 9, 10)
- [x] Write whole-file match tests (AC: 11, 12)
- [x] Write Match struct tests (AC: 13, 14, 15)
- [x] Write SearchResult helper method tests (AC: 16, 17)
- [x] Write empty query tests (AC: 18)
- [x] Ensure test quality standards (AC: 19, 20, 21, 22)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `rdump/tests/library_api.rs` covering integration-level library searches, semantic queries, whole-file matches, helper methods, and preset handling with isolated temp fixtures.
  - Included reusable `create_rust_fixtures` and `create_multi_lang_fixtures` helpers for deterministic tempdir-based tests.
  - Validated via `cargo test --test library_api` and full suite `cargo test` (includes doctests).
- File List:
  - rdump/tests/library_api.rs

## Dev Notes

### Location
- Test file: `tests/library_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 13]

### Why tempdir?
Using `tempfile::tempdir()` ensures:
- Tests are isolated from each other
- Cleanup happens automatically when `TempDir` drops
- No pollution of the actual file system
- Tests can run in parallel safely

### Test Dependencies
Add to `Cargo.toml`:
```toml
[dev-dependencies]
tempfile = "3"
```

### Running Tests
```bash
cargo test --test library_api
```

### Complete Implementation

```rust
//! Integration tests for the rdump library API
//!
//! These tests verify the public search API functions correctly with
//! real file system operations using temporary directories.

use anyhow::Result;
use rdump::{search, search_iter, Match, SearchOptions, SearchResult};
use std::fs;
use std::path::PathBuf;
use tempfile::tempdir;

// =============================================================================
// Test Fixtures
// =============================================================================

/// Create a test directory with sample Rust files
fn create_rust_fixtures() -> Result<tempfile::TempDir> {
    let dir = tempdir()?;

    // Simple main.rs
    fs::write(
        dir.path().join("main.rs"),
        r#"fn main() {
    println!("Hello, world!");
}
"#,
    )?;

    // lib.rs with multiple functions
    fs::write(
        dir.path().join("lib.rs"),
        r#"pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
}
"#,
    )?;

    // Nested file
    let subdir = dir.path().join("src");
    fs::create_dir(&subdir)?;
    fs::write(
        subdir.join("utils.rs"),
        r#"pub fn helper() -> String {
    "helper".to_string()
}
"#,
    )?;

    Ok(dir)
}

/// Create a test directory with multiple languages
fn create_multi_lang_fixtures() -> Result<tempfile::TempDir> {
    let dir = tempdir()?;

    fs::write(dir.path().join("script.py"), "def main():\n    print('hello')\n")?;
    fs::write(dir.path().join("app.js"), "function main() {\n  console.log('hello');\n}\n")?;
    fs::write(dir.path().join("lib.rs"), "fn main() {}\n")?;

    Ok(dir)
}

// =============================================================================
// Basic Search Tests
// =============================================================================

#[test]
fn test_basic_extension_search() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs, lib.rs, and src/utils.rs
    assert_eq!(results.len(), 3);

    // All results should be .rs files
    for result in &results {
        assert!(result.path.extension().unwrap() == "rs");
    }

    Ok(())
}

#[test]
fn test_search_with_no_results() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert!(results.is_empty());

    Ok(())
}

#[test]
fn test_search_nonexistent_root() {
    let result = search("ext:rs", SearchOptions {
        root: PathBuf::from("/nonexistent/path/that/does/not/exist"),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_invalid_query_syntax() {
    let dir = tempdir().unwrap();

    let result = search("invalid((syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    assert!(result.is_err());
    let err = result.unwrap_err().to_string();
    // Error should mention parsing/syntax issue
    assert!(err.contains("parse") || err.contains("syntax") || err.contains("unexpected"));
}

// =============================================================================
// Semantic Search Tests
// =============================================================================

#[test]
fn test_function_predicate() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs (has fn main)
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "main.rs");

    // Should have actual matches (not whole-file)
    assert!(!results[0].is_whole_file_match());
    assert!(!results[0].matches.is_empty());

    // Match should be the main function
    let m = &results[0].matches[0];
    assert_eq!(m.start_line, 1);
    assert!(m.text.contains("fn main"));

    Ok(())
}

#[test]
fn test_function_predicate_multiple_matches() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("func:add | func:subtract", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find lib.rs (has add and subtract)
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "lib.rs");

    // Should have two matches
    assert_eq!(results[0].matches.len(), 2);

    Ok(())
}

// =============================================================================
// Compound Query Tests
// =============================================================================

#[test]
fn test_and_query() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Find .rs files containing 'main' function
    let results = search("ext:rs & func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "main.rs");

    Ok(())
}

#[test]
fn test_or_query() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Find Python or JavaScript files
    let results = search("ext:py | ext:js", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 2);

    let extensions: Vec<_> = results
        .iter()
        .map(|r| r.path.extension().unwrap().to_str().unwrap())
        .collect();

    assert!(extensions.contains(&"py"));
    assert!(extensions.contains(&"js"));

    Ok(())
}

#[test]
fn test_not_query() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Find non-Rust files
    let results = search("!ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 2);

    for result in &results {
        assert_ne!(result.path.extension().unwrap(), "rs");
    }

    Ok(())
}

#[test]
fn test_complex_compound_query() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Find .rs files with test attribute OR main function
    let results = search("ext:rs & (content:test | func:main)", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs and lib.rs (which has #[test])
    assert_eq!(results.len(), 2);

    Ok(())
}

// =============================================================================
// Whole-File Match Tests
// =============================================================================

#[test]
fn test_whole_file_match() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Extension predicates result in whole-file matches
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    for result in &results {
        // Extension matches are whole-file (no specific hunks)
        assert!(result.is_whole_file_match());
        assert!(result.matches.is_empty());
        // But content is still loaded
        assert!(!result.content.is_empty());
    }

    Ok(())
}

#[test]
fn test_whole_file_match_content_available() -> Result<()> {
    let dir = tempdir()?;
    let content = "fn specific_content() { 42 }";
    fs::write(dir.path().join("test.rs"), content)?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].is_whole_file_match());
    assert_eq!(results[0].content, content);

    Ok(())
}

// =============================================================================
// Match Struct Tests
// =============================================================================

#[test]
fn test_match_line_numbers_are_one_indexed() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "// line 1\n// line 2\nfn target() {}\n// line 4\n",
    )?;

    let results = search("func:target", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    let m = &results[0].matches[0];

    // Function is on line 3 (1-indexed)
    assert_eq!(m.start_line, 3);
    assert_eq!(m.end_line, 3);

    Ok(())
}

#[test]
fn test_match_multiline() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        r#"fn multiline(
    arg1: i32,
    arg2: i32,
) -> i32 {
    arg1 + arg2
}"#,
    )?;

    let results = search("func:multiline", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    let m = &results[0].matches[0];

    // Function spans multiple lines
    assert_eq!(m.start_line, 1);
    assert_eq!(m.end_line, 6);
    assert!(m.is_multiline());
    assert_eq!(m.line_count(), 6);

    Ok(())
}

#[test]
fn test_match_byte_range() -> Result<()> {
    let dir = tempdir()?;
    let content = "fn foo() {}";
    fs::write(dir.path().join("test.rs"), content)?;

    let results = search("func:foo", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let m = &results[0].matches[0];

    // Byte range should extract the function
    assert_eq!(&content[m.byte_range.clone()], m.text);

    Ok(())
}

// =============================================================================
// SearchResult Helper Method Tests
// =============================================================================

#[test]
fn test_matched_lines_helper() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "fn a() {}\nfn b() {}\nfn c() {}\n",
    )?;

    // Search that will match multiple functions
    let results = search("func:a | func:b | func:c", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let lines = results[0].matched_lines();

    // Should have lines 1, 2, 3
    assert_eq!(lines, vec![1, 2, 3]);

    Ok(())
}

#[test]
fn test_match_count_helper() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "fn a() {}\nfn b() {}\nfn c() {}\n",
    )?;

    let results = search("func:a | func:b", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results[0].match_count(), 2);

    Ok(())
}

// =============================================================================
// Empty Query Tests
// =============================================================================

#[test]
fn test_empty_query_with_preset() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Empty query with rust preset should return all Rust files
    let results = search("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string()],
        ..Default::default()
    })?;

    // Should find only the .rs file
    assert_eq!(results.len(), 1);
    assert!(results[0].path.extension().unwrap() == "rs");

    Ok(())
}
```

### Testing

**Test Location:** `tests/library_api.rs`

**Test Categories:**
- Basic searches (extension, no results, errors)
- Semantic searches (function predicates)
- Compound queries (AND, OR, NOT, complex)
- Whole-file matches
- Match struct behavior
- Helper methods
- [Source: docs/architecture.md#test-strategy]

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Comprehensive integration test suite covering all aspects of the library API. Tests are well-organized into categories with clear fixtures and deterministic behavior.

**Implementation Highlights:**
- Well-structured fixtures: `create_rust_fixtures()` and `create_multi_lang_fixtures()`
- Clear test organization: Basic, Semantic, Compound, Whole-File, Match, Helper sections
- ENV_MUTEX for thread-safe preset testing (line 9)
- Descriptive assertions with error messages
- Automatic cleanup via TempDir

**Code Location:** `rdump/tests/library_api.rs` (469 lines)

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ Idiomatic Rust test patterns
- Project Structure: ✓ Tests in correct location
- Testing Strategy: ✓ All 18 tests pass
- All ACs Met: ✓ All 22 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

**Test Coverage (18/18):**
- [x] test_basic_extension_search (lines 71-87)
- [x] test_search_with_no_results (lines 89-103)
- [x] test_search_nonexistent_root (lines 105-116)
- [x] test_invalid_query_syntax (lines 118-133)
- [x] test_function_predicate (lines 139-159)
- [x] test_function_predicate_multiple_matches (lines 161-177)
- [x] test_and_query (lines 183-198)
- [x] test_or_query (lines 200-220)
- [x] test_not_query (lines 222-239)
- [x] test_complex_compound_query (lines 241-260)
- [x] test_whole_file_match (lines 266-285)
- [x] test_whole_file_match_content_available (lines 287-305)
- [x] test_match_line_numbers_are_one_indexed (lines 311-332)
- [x] test_match_multiline (lines 334-363)
- [x] test_match_byte_range (lines 365-382)
- [x] test_matched_lines_helper (lines 388-407)
- [x] test_match_count_helper (lines 409-427)
- [x] test_empty_query_with_preset (lines 433-468)

**Test Quality (4/4):**
- [x] All tests use tempdir() for isolation
- [x] Tests clean up automatically (TempDir drops)
- [x] Tests are deterministic (ENV_MUTEX for thread safety)
- [x] Tests have clear assertions with error messages

### Security Review

No security concerns - test suite uses isolated temp directories.

### Performance Considerations

**Efficient test design:**
- Fixtures are lightweight and fast to create
- Tests run in parallel safely
- No external dependencies or network calls

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.13-write-core-integration-tests.yml

### Recommended Status

✓ Ready for Done

All 22 acceptance criteria have been met, all 18 tests pass, and the implementation provides comprehensive end-to-end verification of the library API.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 0.2 | Added core library integration tests and fixtures | Dev Agent |
| 2025-11-21 | 1.0 | QA Review completed - all 22 ACs verified | Quinn (QA) |
