# Story 1.13: Write Core Integration Tests

## Status
Draft

## Story
**As a** library maintainer,
**I want** comprehensive integration tests for basic library functionality,
**so that** the public API is verified to work correctly end-to-end with real file system operations.

## Acceptance Criteria

**Test Coverage:**
1. - [ ] `test_basic_extension_search` - passes
2. - [ ] `test_search_with_no_results` - passes
3. - [ ] `test_search_nonexistent_root` - passes
4. - [ ] `test_invalid_query_syntax` - passes
5. - [ ] `test_function_predicate` - passes
6. - [ ] `test_function_predicate_multiple_matches` - passes
7. - [ ] `test_and_query` - passes
8. - [ ] `test_or_query` - passes
9. - [ ] `test_not_query` - passes
10. - [ ] `test_complex_compound_query` - passes
11. - [ ] `test_whole_file_match` - passes
12. - [ ] `test_whole_file_match_content_available` - passes
13. - [ ] `test_match_line_numbers_are_one_indexed` - passes
14. - [ ] `test_match_multiline` - passes
15. - [ ] `test_match_byte_range` - passes
16. - [ ] `test_matched_lines_helper` - passes
17. - [ ] `test_match_count_helper` - passes
18. - [ ] `test_empty_query_with_preset` - passes

**Test Quality:**
19. - [ ] All tests use `tempdir()` for isolation
20. - [ ] Tests clean up automatically
21. - [ ] Tests are deterministic (no timing dependencies)
22. - [ ] Tests have clear assertions with good error messages

## Tasks / Subtasks

- [ ] Create test file `tests/library_api.rs`
- [ ] Create test fixtures
  - [ ] `create_rust_fixtures()` - sample Rust files
  - [ ] `create_multi_lang_fixtures()` - multiple language files
- [ ] Write basic search tests (AC: 1, 2, 3, 4)
- [ ] Write semantic search tests (AC: 5, 6)
- [ ] Write compound query tests (AC: 7, 8, 9, 10)
- [ ] Write whole-file match tests (AC: 11, 12)
- [ ] Write Match struct tests (AC: 13, 14, 15)
- [ ] Write SearchResult helper method tests (AC: 16, 17)
- [ ] Write empty query tests (AC: 18)
- [ ] Ensure test quality standards (AC: 19, 20, 21, 22)

## Dev Notes

### Location
- Test file: `tests/library_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 13]

### Why tempdir?
Using `tempfile::tempdir()` ensures:
- Tests are isolated from each other
- Cleanup happens automatically when `TempDir` drops
- No pollution of the actual file system
- Tests can run in parallel safely

### Test Dependencies
Add to `Cargo.toml`:
```toml
[dev-dependencies]
tempfile = "3"
```

### Running Tests
```bash
cargo test --test library_api
```

### Complete Implementation

```rust
//! Integration tests for the rdump library API
//!
//! These tests verify the public search API functions correctly with
//! real file system operations using temporary directories.

use anyhow::Result;
use rdump::{search, search_iter, Match, SearchOptions, SearchResult};
use std::fs;
use std::path::PathBuf;
use tempfile::tempdir;

// =============================================================================
// Test Fixtures
// =============================================================================

/// Create a test directory with sample Rust files
fn create_rust_fixtures() -> Result<tempfile::TempDir> {
    let dir = tempdir()?;

    // Simple main.rs
    fs::write(
        dir.path().join("main.rs"),
        r#"fn main() {
    println!("Hello, world!");
}
"#,
    )?;

    // lib.rs with multiple functions
    fs::write(
        dir.path().join("lib.rs"),
        r#"pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

pub fn subtract(a: i32, b: i32) -> i32 {
    a - b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }
}
"#,
    )?;

    // Nested file
    let subdir = dir.path().join("src");
    fs::create_dir(&subdir)?;
    fs::write(
        subdir.join("utils.rs"),
        r#"pub fn helper() -> String {
    "helper".to_string()
}
"#,
    )?;

    Ok(dir)
}

/// Create a test directory with multiple languages
fn create_multi_lang_fixtures() -> Result<tempfile::TempDir> {
    let dir = tempdir()?;

    fs::write(dir.path().join("script.py"), "def main():\n    print('hello')\n")?;
    fs::write(dir.path().join("app.js"), "function main() {\n  console.log('hello');\n}\n")?;
    fs::write(dir.path().join("lib.rs"), "fn main() {}\n")?;

    Ok(dir)
}

// =============================================================================
// Basic Search Tests
// =============================================================================

#[test]
fn test_basic_extension_search() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs, lib.rs, and src/utils.rs
    assert_eq!(results.len(), 3);

    // All results should be .rs files
    for result in &results {
        assert!(result.path.extension().unwrap() == "rs");
    }

    Ok(())
}

#[test]
fn test_search_with_no_results() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("ext:py", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert!(results.is_empty());

    Ok(())
}

#[test]
fn test_search_nonexistent_root() {
    let result = search("ext:rs", SearchOptions {
        root: PathBuf::from("/nonexistent/path/that/does/not/exist"),
        ..Default::default()
    });

    assert!(result.is_err());
}

#[test]
fn test_invalid_query_syntax() {
    let dir = tempdir().unwrap();

    let result = search("invalid((syntax", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    });

    assert!(result.is_err());
    let err = result.unwrap_err().to_string();
    // Error should mention parsing/syntax issue
    assert!(err.contains("parse") || err.contains("syntax") || err.contains("unexpected"));
}

// =============================================================================
// Semantic Search Tests
// =============================================================================

#[test]
fn test_function_predicate() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs (has fn main)
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "main.rs");

    // Should have actual matches (not whole-file)
    assert!(!results[0].is_whole_file_match());
    assert!(!results[0].matches.is_empty());

    // Match should be the main function
    let m = &results[0].matches[0];
    assert_eq!(m.start_line, 1);
    assert!(m.text.contains("fn main"));

    Ok(())
}

#[test]
fn test_function_predicate_multiple_matches() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let results = search("func:add | func:subtract", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find lib.rs (has add and subtract)
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "lib.rs");

    // Should have two matches
    assert_eq!(results[0].matches.len(), 2);

    Ok(())
}

// =============================================================================
// Compound Query Tests
// =============================================================================

#[test]
fn test_and_query() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Find .rs files containing 'main' function
    let results = search("ext:rs & func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "main.rs");

    Ok(())
}

#[test]
fn test_or_query() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Find Python or JavaScript files
    let results = search("ext:py | ext:js", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 2);

    let extensions: Vec<_> = results
        .iter()
        .map(|r| r.path.extension().unwrap().to_str().unwrap())
        .collect();

    assert!(extensions.contains(&"py"));
    assert!(extensions.contains(&"js"));

    Ok(())
}

#[test]
fn test_not_query() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Find non-Rust files
    let results = search("!ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 2);

    for result in &results {
        assert_ne!(result.path.extension().unwrap(), "rs");
    }

    Ok(())
}

#[test]
fn test_complex_compound_query() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Find .rs files with test attribute OR main function
    let results = search("ext:rs & (content:test | func:main)", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should find main.rs and lib.rs (which has #[test])
    assert_eq!(results.len(), 2);

    Ok(())
}

// =============================================================================
// Whole-File Match Tests
// =============================================================================

#[test]
fn test_whole_file_match() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Extension predicates result in whole-file matches
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    for result in &results {
        // Extension matches are whole-file (no specific hunks)
        assert!(result.is_whole_file_match());
        assert!(result.matches.is_empty());
        // But content is still loaded
        assert!(!result.content.is_empty());
    }

    Ok(())
}

#[test]
fn test_whole_file_match_content_available() -> Result<()> {
    let dir = tempdir()?;
    let content = "fn specific_content() { 42 }";
    fs::write(dir.path().join("test.rs"), content)?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].is_whole_file_match());
    assert_eq!(results[0].content, content);

    Ok(())
}

// =============================================================================
// Match Struct Tests
// =============================================================================

#[test]
fn test_match_line_numbers_are_one_indexed() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "// line 1\n// line 2\nfn target() {}\n// line 4\n",
    )?;

    let results = search("func:target", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    let m = &results[0].matches[0];

    // Function is on line 3 (1-indexed)
    assert_eq!(m.start_line, 3);
    assert_eq!(m.end_line, 3);

    Ok(())
}

#[test]
fn test_match_multiline() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        r#"fn multiline(
    arg1: i32,
    arg2: i32,
) -> i32 {
    arg1 + arg2
}"#,
    )?;

    let results = search("func:multiline", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    let m = &results[0].matches[0];

    // Function spans multiple lines
    assert_eq!(m.start_line, 1);
    assert_eq!(m.end_line, 6);
    assert!(m.is_multiline());
    assert_eq!(m.line_count(), 6);

    Ok(())
}

#[test]
fn test_match_byte_range() -> Result<()> {
    let dir = tempdir()?;
    let content = "fn foo() {}";
    fs::write(dir.path().join("test.rs"), content)?;

    let results = search("func:foo", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let m = &results[0].matches[0];

    // Byte range should extract the function
    assert_eq!(&content[m.byte_range.clone()], m.text);

    Ok(())
}

// =============================================================================
// SearchResult Helper Method Tests
// =============================================================================

#[test]
fn test_matched_lines_helper() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "fn a() {}\nfn b() {}\nfn c() {}\n",
    )?;

    // Search that will match multiple functions
    let results = search("func:a | func:b | func:c", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let lines = results[0].matched_lines();

    // Should have lines 1, 2, 3
    assert_eq!(lines, vec![1, 2, 3]);

    Ok(())
}

#[test]
fn test_match_count_helper() -> Result<()> {
    let dir = tempdir()?;
    fs::write(
        dir.path().join("test.rs"),
        "fn a() {}\nfn b() {}\nfn c() {}\n",
    )?;

    let results = search("func:a | func:b", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results[0].match_count(), 2);

    Ok(())
}

// =============================================================================
// Empty Query Tests
// =============================================================================

#[test]
fn test_empty_query_with_preset() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Empty query with rust preset should return all Rust files
    let results = search("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string()],
        ..Default::default()
    })?;

    // Should find only the .rs file
    assert_eq!(results.len(), 1);
    assert!(results[0].path.extension().unwrap() == "rs");

    Ok(())
}
```

### Testing

**Test Location:** `tests/library_api.rs`

**Test Categories:**
- Basic searches (extension, no results, errors)
- Semantic searches (function predicates)
- Compound queries (AND, OR, NOT, complex)
- Whole-file matches
- Match struct behavior
- Helper methods
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
