# Story 1.7: Implement ranges_to_matches Helper

## Status
Done

## Story
**As a** library maintainer,
**I want** a helper function to convert tree-sitter `Range` to user-friendly `Match` structs,
**so that** the index conversion and text extraction is handled safely and consistently.

## Acceptance Criteria

1. - [x] Converts 0-indexed `row` to 1-indexed `start_line`/`end_line`
2. - [x] Preserves 0-indexed `column` values
3. - [x] Preserves byte range values
4. - [x] Uses `.get()` for safe Unicode boundary handling
5. - [x] Returns None (filtered out) for invalid ranges
6. - [x] Handles empty content string
7. - [x] Empty ranges vector returns empty matches
8. - [x] Single-character matches work correctly
9. - [x] Multi-byte Unicode characters handled correctly

## Tasks / Subtasks

- [x] Create `ranges_to_matches` function in `src/lib.rs` (AC: 1, 2, 3)
  - [x] Accept `content: &str` and `ranges: &[tree_sitter::Range]`
  - [x] Return `Vec<Match>`
- [x] Implement safe text extraction (AC: 4, 5)
  - [x] Use `.get()` instead of direct indexing
  - [x] Filter out invalid ranges with `filter_map`
- [x] Handle edge cases (AC: 6, 7, 8, 9)
- [x] Write comprehensive unit tests

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Reworked `ranges_to_matches` to return early on empty content and use `filter_map` with `.get()` for Unicode-safe slicing, filtering invalid ranges, and preserving byte ranges/columns.
  - Added unit tests covering invalid ranges, Unicode boundaries, empty inputs, single-character and multiline ranges to satisfy acceptance criteria.
  - Test suite passes locally except preset-related tests that require writing to global config (`/Users/alm/Library/Application Support/rdump/config.toml`), which is blocked in the current environment.
- File List:
  - rdump/src/lib.rs

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 7]

### Complete Implementation

```rust
/// Convert tree-sitter Range to user-friendly Match
///
/// Handles:
/// - 0-indexed to 1-indexed line number conversion
/// - Byte range extraction
/// - Unicode-safe text extraction
fn ranges_to_matches(content: &str, ranges: &[tree_sitter::Range]) -> Vec<Match> {
    ranges
        .iter()
        .filter_map(|r| {
            // Extract text using byte range
            // Use .get() for safe handling of invalid ranges
            let text = content
                .get(r.start_byte..r.end_byte)?
                .to_string();

            Some(Match {
                // Convert 0-indexed rows to 1-indexed line numbers
                start_line: r.start_point.row + 1,
                end_line: r.end_point.row + 1,
                // Columns stay 0-indexed (byte offset within line)
                start_column: r.start_point.column,
                end_column: r.end_point.column,
                // Byte range stays as-is
                byte_range: r.start_byte..r.end_byte,
                text,
            })
        })
        .collect()
}
```

### Alternative: With Better Error Handling

```rust
/// Error information for range conversion failures
#[derive(Debug)]
pub struct RangeConversionError {
    pub index: usize,
    pub range: tree_sitter::Range,
    pub reason: &'static str,
}

/// Convert ranges with detailed error information
fn ranges_to_matches_with_errors(
    content: &str,
    ranges: &[tree_sitter::Range],
) -> (Vec<Match>, Vec<RangeConversionError>) {
    let mut matches = Vec::with_capacity(ranges.len());
    let mut errors = Vec::new();

    for (i, r) in ranges.iter().enumerate() {
        match content.get(r.start_byte..r.end_byte) {
            Some(text) => {
                matches.push(Match {
                    start_line: r.start_point.row + 1,
                    end_line: r.end_point.row + 1,
                    start_column: r.start_point.column,
                    end_column: r.end_point.column,
                    byte_range: r.start_byte..r.end_byte,
                    text: text.to_string(),
                });
            }
            None => {
                errors.push(RangeConversionError {
                    index: i,
                    range: r.clone(),
                    reason: "Invalid byte range for content",
                });
            }
        }
    }

    (matches, errors)
}
```

### Why filter_map instead of map?
Invalid byte ranges (e.g., from corrupted tree-sitter output or race conditions where file changed) are silently dropped rather than causing panics. This makes the library more robust.

### Unicode Safety
Using `.get()` instead of direct indexing (`content[start..end]`) prevents panics when byte indices fall in the middle of a multi-byte UTF-8 character.

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Content must be valid UTF-8 - skip binary files
- Never use `unwrap()` on user data

### Complete Test Cases

**Test Location:** Unit tests in `src/lib.rs`

```rust
#[test]
fn test_ranges_to_matches_basic() {
    let content = "line one\nline two\nline three";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 8,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 8 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].start_line, 1);  // 0-indexed row 0 -> 1-indexed line 1
    assert_eq!(matches[0].text, "line one");
}

#[test]
fn test_ranges_to_matches_unicode() {
    let content = "fn ä½ å¥½() {}";
    let ranges = vec![
        Range {
            start_byte: 3,
            end_byte: 9,  // ä½ å¥½ is 6 bytes in UTF-8
            start_point: Point { row: 0, column: 3 },
            end_point: Point { row: 0, column: 9 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches[0].text, "ä½ å¥½");
}

#[test]
fn test_ranges_to_matches_invalid_range() {
    let content = "short";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 100,  // Beyond content length
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 100 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 0);  // Invalid range filtered out
}

#[test]
fn test_ranges_to_matches_empty_ranges() {
    let content = "some content";
    let ranges: Vec<Range> = vec![];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 0);
}

#[test]
fn test_ranges_to_matches_single_character() {
    let content = "x";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 1,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 1 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].text, "x");
}

#[test]
fn test_ranges_to_matches_multiline() {
    let content = "fn main() {\n    println!(\"hello\");\n}";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 36,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 2, column: 1 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].start_line, 1);
    assert_eq!(matches[0].end_line, 3);  // Row 2 -> Line 3
}

#[test]
fn test_ranges_to_matches_emoji() {
    let content = "let crab = 'ðŸ¦€';";
    let ranges = vec![
        Range {
            start_byte: 12,
            end_byte: 16,  // ðŸ¦€ is 4 bytes in UTF-8
            start_point: Point { row: 0, column: 12 },
            end_point: Point { row: 0, column: 16 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches[0].text, "ðŸ¦€");
}

#[test]
fn test_ranges_to_matches_multiple_ranges() {
    let content = "fn a() {}\nfn b() {}";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 9,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 9 },
        },
        Range {
            start_byte: 10,
            end_byte: 19,
            start_point: Point { row: 1, column: 0 },
            end_point: Point { row: 1, column: 9 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 2);
    assert_eq!(matches[0].text, "fn a() {}");
    assert_eq!(matches[0].start_line, 1);
    assert_eq!(matches[1].text, "fn b() {}");
    assert_eq!(matches[1].start_line, 2);
}
```

### Edge Case Handling

1. **Empty content string**: Returns empty Vec since no ranges can be valid
2. **Overlapping ranges**: Each range is converted independently; overlaps are allowed
3. **Invalid UTF-8 boundaries**: `.get()` returns None, range is filtered out
4. **Zero-length ranges**: Valid if start_byte == end_byte, results in empty string text

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation is clean and handles Unicode safely using idiomatic Rust patterns. The `filter_map` with `?` operator elegantly filters out invalid ranges while extracting text.

**Implementation Highlights:**
- Early return for empty content (optimization)
- Uses `.get()` with `?` for Unicode-safe slicing
- Clean `filter_map` pattern to filter invalid ranges
- Proper line index conversion (0â†’1 indexed)
- Columns and byte ranges preserved as-is

**Code Location:** `rdump/src/lib.rs:342-363`

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: âœ“ No unwrap() on user data, uses safe `.get()` for slicing
- Project Structure: âœ“ Code is in correct location (src/lib.rs)
- Testing Strategy: âœ“ Test passes for bounds and conversion
- All ACs Met: âœ“ All 9 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

- [x] Converts 0-indexed row to 1-indexed line (lines 354-355)
- [x] Preserves 0-indexed column values (lines 356-357)
- [x] Preserves byte range values (line 358)
- [x] Uses .get() for safe Unicode boundary handling (line 351)
- [x] Returns None for invalid ranges (filter_map with ?)
- [x] Handles empty content string (lines 344-346)
- [x] Empty ranges vector returns empty matches
- [x] Single-character matches work correctly
- [x] Multi-byte Unicode characters handled correctly

### Security Review

No security concerns - safe slicing prevents panics on invalid byte ranges or Unicode boundaries.

### Performance Considerations

**Efficient implementation:**
- Early return for empty content avoids unnecessary iteration
- `filter_map` processes in single pass
- No intermediate collections

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS â†’ docs/qa/gates/1.7-implement-ranges-to-matches.yml

### Recommended Status

âœ“ Ready for Done

All 9 acceptance criteria have been met, test passes, and the implementation provides safe Unicode-aware range-to-match conversion.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 1.0 | Implemented ranges_to_matches with Unicode-safe extraction and tests | Dev Agent |
