# Story 1.7: Implement ranges_to_matches Helper

## Status
Draft

## Story
**As a** library maintainer,
**I want** a helper function to convert tree-sitter `Range` to user-friendly `Match` structs,
**so that** the index conversion and text extraction is handled safely and consistently.

## Acceptance Criteria

1. - [ ] Converts 0-indexed `row` to 1-indexed `start_line`/`end_line`
2. - [ ] Preserves 0-indexed `column` values
3. - [ ] Preserves byte range values
4. - [ ] Uses `.get()` for safe Unicode boundary handling
5. - [ ] Returns None (filtered out) for invalid ranges
6. - [ ] Handles empty content string
7. - [ ] Empty ranges vector returns empty matches
8. - [ ] Single-character matches work correctly
9. - [ ] Multi-byte Unicode characters handled correctly

## Tasks / Subtasks

- [ ] Create `ranges_to_matches` function in `src/lib.rs` (AC: 1, 2, 3)
  - [ ] Accept `content: &str` and `ranges: &[tree_sitter::Range]`
  - [ ] Return `Vec<Match>`
- [ ] Implement safe text extraction (AC: 4, 5)
  - [ ] Use `.get()` instead of direct indexing
  - [ ] Filter out invalid ranges with `filter_map`
- [ ] Handle edge cases (AC: 6, 7, 8, 9)
- [ ] Write comprehensive unit tests

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 7]

### Complete Implementation

```rust
/// Convert tree-sitter Range to user-friendly Match
///
/// Handles:
/// - 0-indexed to 1-indexed line number conversion
/// - Byte range extraction
/// - Unicode-safe text extraction
fn ranges_to_matches(content: &str, ranges: &[tree_sitter::Range]) -> Vec<Match> {
    ranges
        .iter()
        .filter_map(|r| {
            // Extract text using byte range
            // Use .get() for safe handling of invalid ranges
            let text = content
                .get(r.start_byte..r.end_byte)?
                .to_string();

            Some(Match {
                // Convert 0-indexed rows to 1-indexed line numbers
                start_line: r.start_point.row + 1,
                end_line: r.end_point.row + 1,
                // Columns stay 0-indexed (byte offset within line)
                start_column: r.start_point.column,
                end_column: r.end_point.column,
                // Byte range stays as-is
                byte_range: r.start_byte..r.end_byte,
                text,
            })
        })
        .collect()
}
```

### Alternative: With Better Error Handling

```rust
/// Error information for range conversion failures
#[derive(Debug)]
pub struct RangeConversionError {
    pub index: usize,
    pub range: tree_sitter::Range,
    pub reason: &'static str,
}

/// Convert ranges with detailed error information
fn ranges_to_matches_with_errors(
    content: &str,
    ranges: &[tree_sitter::Range],
) -> (Vec<Match>, Vec<RangeConversionError>) {
    let mut matches = Vec::with_capacity(ranges.len());
    let mut errors = Vec::new();

    for (i, r) in ranges.iter().enumerate() {
        match content.get(r.start_byte..r.end_byte) {
            Some(text) => {
                matches.push(Match {
                    start_line: r.start_point.row + 1,
                    end_line: r.end_point.row + 1,
                    start_column: r.start_point.column,
                    end_column: r.end_point.column,
                    byte_range: r.start_byte..r.end_byte,
                    text: text.to_string(),
                });
            }
            None => {
                errors.push(RangeConversionError {
                    index: i,
                    range: r.clone(),
                    reason: "Invalid byte range for content",
                });
            }
        }
    }

    (matches, errors)
}
```

### Why filter_map instead of map?
Invalid byte ranges (e.g., from corrupted tree-sitter output or race conditions where file changed) are silently dropped rather than causing panics. This makes the library more robust.

### Unicode Safety
Using `.get()` instead of direct indexing (`content[start..end]`) prevents panics when byte indices fall in the middle of a multi-byte UTF-8 character.

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Content must be valid UTF-8 - skip binary files
- Never use `unwrap()` on user data

### Complete Test Cases

**Test Location:** Unit tests in `src/lib.rs`

```rust
#[test]
fn test_ranges_to_matches_basic() {
    let content = "line one\nline two\nline three";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 8,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 8 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].start_line, 1);  // 0-indexed row 0 -> 1-indexed line 1
    assert_eq!(matches[0].text, "line one");
}

#[test]
fn test_ranges_to_matches_unicode() {
    let content = "fn ä½ å¥½() {}";
    let ranges = vec![
        Range {
            start_byte: 3,
            end_byte: 9,  // ä½ å¥½ is 6 bytes in UTF-8
            start_point: Point { row: 0, column: 3 },
            end_point: Point { row: 0, column: 9 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches[0].text, "ä½ å¥½");
}

#[test]
fn test_ranges_to_matches_invalid_range() {
    let content = "short";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 100,  // Beyond content length
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 100 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 0);  // Invalid range filtered out
}

#[test]
fn test_ranges_to_matches_empty_ranges() {
    let content = "some content";
    let ranges: Vec<Range> = vec![];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 0);
}

#[test]
fn test_ranges_to_matches_single_character() {
    let content = "x";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 1,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 1 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].text, "x");
}

#[test]
fn test_ranges_to_matches_multiline() {
    let content = "fn main() {\n    println!(\"hello\");\n}";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 36,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 2, column: 1 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 1);
    assert_eq!(matches[0].start_line, 1);
    assert_eq!(matches[0].end_line, 3);  // Row 2 -> Line 3
}

#[test]
fn test_ranges_to_matches_emoji() {
    let content = "let crab = 'ðŸ¦€';";
    let ranges = vec![
        Range {
            start_byte: 12,
            end_byte: 16,  // ðŸ¦€ is 4 bytes in UTF-8
            start_point: Point { row: 0, column: 12 },
            end_point: Point { row: 0, column: 16 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches[0].text, "ðŸ¦€");
}

#[test]
fn test_ranges_to_matches_multiple_ranges() {
    let content = "fn a() {}\nfn b() {}";
    let ranges = vec![
        Range {
            start_byte: 0,
            end_byte: 9,
            start_point: Point { row: 0, column: 0 },
            end_point: Point { row: 0, column: 9 },
        },
        Range {
            start_byte: 10,
            end_byte: 19,
            start_point: Point { row: 1, column: 0 },
            end_point: Point { row: 1, column: 9 },
        },
    ];

    let matches = ranges_to_matches(content, &ranges);

    assert_eq!(matches.len(), 2);
    assert_eq!(matches[0].text, "fn a() {}");
    assert_eq!(matches[0].start_line, 1);
    assert_eq!(matches[1].text, "fn b() {}");
    assert_eq!(matches[1].start_line, 2);
}
```

### Edge Case Handling

1. **Empty content string**: Returns empty Vec since no ranges can be valid
2. **Overlapping ranges**: Each range is converted independently; overlaps are allowed
3. **Invalid UTF-8 boundaries**: `.get()` returns None, range is filtered out
4. **Zero-length ranges**: Valid if start_byte == end_byte, results in empty string text

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
