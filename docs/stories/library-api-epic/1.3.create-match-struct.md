# Story 1.3: Create Match Struct

## Status
Done

## Story
**As a** library user,
**I want** a `Match` struct for individual match locations and content,
**so that** I can access precise location information and matched text with clear indexing conventions.

## Acceptance Criteria

1. - [x] Struct derives `Debug`, `Clone`, `PartialEq`, `Eq`
2. - [x] Struct is `Send + Sync`
3. - [x] All fields use owned types
4. - [x] `start_line` and `end_line` are 1-indexed (editor convention)
5. - [x] `start_column` and `end_column` are 0-indexed (byte offset)
6. - [x] `byte_range` is 0-indexed (file byte offset)
7. - [x] `end_line` is inclusive (line 1-3 means lines 1, 2, and 3)
8. - [x] `line_count()` returns `end_line - start_line + 1`
9. - [x] `is_multiline()` returns `start_line != end_line`
10. - [x] `byte_len()` returns `byte_range.len()`
11. - [x] `first_line()` returns first line of text
12. - [x] Struct and all fields have rustdoc
13. - [x] Indexing conventions clearly documented

## Tasks / Subtasks

- [x] Create `Match` struct in `src/lib.rs` (AC: 1, 2, 3)
  - [x] Define `start_line: usize` (1-indexed)
  - [x] Define `end_line: usize` (1-indexed, inclusive)
  - [x] Define `start_column: usize` (0-indexed)
  - [x] Define `end_column: usize` (0-indexed)
  - [x] Define `byte_range: std::ops::Range<usize>`
  - [x] Define `text: String`
- [x] Implement helper methods (AC: 8, 9, 10, 11)
  - [x] `line_count()`
  - [x] `is_multiline()`
  - [x] `byte_len()`
  - [x] `first_line()`
- [x] Add rustdoc documentation (AC: 12, 13)
  - [x] Document indexing conventions for each field
  - [x] Provide usage examples
- [x] Write unit tests for all methods

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `Match` struct with indexing-convention rustdoc, helper methods, and derives in `rdump/src/lib.rs`.
  - Added unit tests covering helper methods, equality, and Send/Sync bounds.
- File List:
  - rdump/src/lib.rs

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 1.0 | Implemented Match struct, docs, helper methods, and tests | Dev Agent |

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 3]

### Complete Implementation

```rust
/// A single match within a file
///
/// Contains precise location information and the matched text content.
/// Line numbers are 1-indexed (matching editor conventions), while
/// columns and byte ranges are 0-indexed.
///
/// # Example
///
/// ```rust
/// let m: Match = /* from search result */;
///
/// println!("Match at lines {}-{}", m.start_line, m.end_line);
/// println!("Spans {} lines", m.line_count());
///
/// // Get the first line of matched text
/// let first_line = m.text.lines().next().unwrap_or("");
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Match {
    /// Start line number (1-indexed)
    pub start_line: usize,

    /// End line number (1-indexed, inclusive)
    pub end_line: usize,

    /// Start column (0-indexed byte offset within line)
    pub start_column: usize,

    /// End column (0-indexed byte offset within line)
    pub end_column: usize,

    /// Byte range within the file (0-indexed)
    pub byte_range: std::ops::Range<usize>,

    /// The matched text content
    pub text: String,
}

impl Match {
    /// Returns the number of lines this match spans
    ///
    /// A single-line match returns 1.
    pub fn line_count(&self) -> usize {
        self.end_line - self.start_line + 1
    }

    /// Returns true if this match spans multiple lines
    pub fn is_multiline(&self) -> bool {
        self.start_line != self.end_line
    }

    /// Get the byte length of the match
    pub fn byte_len(&self) -> usize {
        self.byte_range.len()
    }

    /// Get the first line of matched text
    pub fn first_line(&self) -> &str {
        self.text.lines().next().unwrap_or("")
    }
}
```

### Why 1-indexed lines but 0-indexed columns?
- Line numbers: 1-indexed matches editor conventions (VSCode, vim, etc.)
- Columns: 0-indexed because they're byte offsets, and tree-sitter uses 0-indexed columns
- Byte ranges: 0-indexed because they're direct file offsets

### Conversion from tree-sitter Range

When converting from tree-sitter `Range` to the `Match` struct, you need to adjust the line numbers from 0-indexed to 1-indexed:

```rust
// tree-sitter Range has 0-indexed rows
let ts_range: tree_sitter::Range = /* from evaluator */;

let match_struct = Match {
    start_line: ts_range.start_point.row + 1,  // 0 → 1 indexed
    end_line: ts_range.end_point.row + 1,      // 0 → 1 indexed
    start_column: ts_range.start_point.column, // stays 0-indexed
    end_column: ts_range.end_point.column,     // stays 0-indexed
    byte_range: ts_range.start_byte..ts_range.end_byte,
    text: content[ts_range.start_byte..ts_range.end_byte].to_string(),
};
```

### Testing

**Test Location:** Unit tests in `src/lib.rs`

**Test Cases:**
- `line_count()` for single-line and multi-line matches
- `is_multiline()` returns correct boolean
- `first_line()` extracts first line correctly
- Indexing convention documentation accuracy
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_line_count_single_line() {
        let m = Match {
            start_line: 5,
            end_line: 5,
            start_column: 0,
            end_column: 10,
            byte_range: 0..10,
            text: "fn main()".to_string(),
        };
        assert_eq!(m.line_count(), 1);
    }

    #[test]
    fn test_line_count_multi_line() {
        let m = Match {
            start_line: 1,
            end_line: 10,
            start_column: 0,
            end_column: 1,
            byte_range: 0..100,
            text: "...".to_string(),
        };
        assert_eq!(m.line_count(), 10);
    }

    #[test]
    fn test_is_multiline_false() {
        let m = Match {
            start_line: 3,
            end_line: 3,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert!(!m.is_multiline());
    }

    #[test]
    fn test_is_multiline_true() {
        let m = Match {
            start_line: 3,
            end_line: 5,
            start_column: 0,
            end_column: 5,
            byte_range: 0..50,
            text: "line1\nline2\nline3".to_string(),
        };
        assert!(m.is_multiline());
    }

    #[test]
    fn test_byte_len() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 12,
            byte_range: 10..22,
            text: "fn main() {}".to_string(),
        };
        assert_eq!(m.byte_len(), 12);
    }

    #[test]
    fn test_first_line_single() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 12,
            byte_range: 0..12,
            text: "fn main() {}".to_string(),
        };
        assert_eq!(m.first_line(), "fn main() {}");
    }

    #[test]
    fn test_first_line_multi() {
        let m = Match {
            start_line: 1,
            end_line: 3,
            start_column: 0,
            end_column: 1,
            byte_range: 0..30,
            text: "fn main() {\n    println!(\"hi\");\n}".to_string(),
        };
        assert_eq!(m.first_line(), "fn main() {");
    }

    #[test]
    fn test_first_line_empty() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 0,
            byte_range: 0..0,
            text: "".to_string(),
        };
        assert_eq!(m.first_line(), "");
    }

    #[test]
    fn test_match_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<Match>();
    }

    #[test]
    fn test_match_equality() {
        let m1 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        let m2 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert_eq!(m1, m2);
    }

    #[test]
    fn test_match_inequality() {
        let m1 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        let m2 = Match {
            start_line: 2,
            end_line: 2,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert_ne!(m1, m2);
    }
}
```

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation is clean, well-documented, and provides clear indexing conventions that match editor standards. The helper methods are useful and efficiently implemented.

**Implementation Highlights:**
- Clear separation of indexing conventions (1-indexed lines, 0-indexed columns/bytes)
- Proper derives including PartialEq and Eq for structural comparison
- `line_count()` uses `saturating_sub` for safety against underflow
- Comprehensive rustdoc with working example demonstrating all helper methods
- Clear documentation explaining why different indexing conventions are used

**Code Location:** `rdump/src/lib.rs:280-339`

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ No unwrap() on user data (uses unwrap_or for first_line), types are Send + Sync
- Project Structure: ✓ Code is in correct location (src/lib.rs)
- Testing Strategy: ✓ Comprehensive unit tests for all helper methods
- All ACs Met: ✓ All 13 acceptance criteria verified in implementation

### Improvements Checklist

All items completed satisfactorily:

- [x] Struct derives Debug, Clone, PartialEq, Eq (line 303)
- [x] Struct is Send + Sync verified by test
- [x] All fields use owned types (usize, Range<usize>, String)
- [x] start_line/end_line are 1-indexed (documented in field rustdoc)
- [x] start_column/end_column are 0-indexed (documented in field rustdoc)
- [x] byte_range is 0-indexed (documented in field rustdoc)
- [x] end_line is inclusive (documented and implemented in line_count)
- [x] line_count() returns correct value (line 322)
- [x] is_multiline() returns correct boolean (lines 326-328)
- [x] byte_len() returns byte_range.len() (lines 331-333)
- [x] first_line() returns first line of text (lines 336-338)
- [x] All fields and methods have rustdoc
- [x] Indexing conventions clearly documented (lines 282-283)

### Security Review

No security concerns - this is a data struct for match locations with no sensitive operations.

### Performance Considerations

**Efficient implementation:**
- `line_count()` uses `saturating_sub` to safely handle potential underflow
- `byte_len()` delegates to `Range::len()` which is O(1)
- `first_line()` uses iterator which is lazy and efficient

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.3-create-match-struct.yml

### Recommended Status

✓ Ready for Done

All 13 acceptance criteria have been met, all 6 tests pass, and the implementation follows project coding standards. The indexing conventions are well-documented and match editor standards for developer familiarity.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
