# Story 1.3: Create Match Struct

## Status
Draft

## Story
**As a** library user,
**I want** a `Match` struct for individual match locations and content,
**so that** I can access precise location information and matched text with clear indexing conventions.

## Acceptance Criteria

1. - [ ] Struct derives `Debug`, `Clone`, `PartialEq`, `Eq`
2. - [ ] Struct is `Send + Sync`
3. - [ ] All fields use owned types
4. - [ ] `start_line` and `end_line` are 1-indexed (editor convention)
5. - [ ] `start_column` and `end_column` are 0-indexed (byte offset)
6. - [ ] `byte_range` is 0-indexed (file byte offset)
7. - [ ] `end_line` is inclusive (line 1-3 means lines 1, 2, and 3)
8. - [ ] `line_count()` returns `end_line - start_line + 1`
9. - [ ] `is_multiline()` returns `start_line != end_line`
10. - [ ] `byte_len()` returns `byte_range.len()`
11. - [ ] `first_line()` returns first line of text
12. - [ ] Struct and all fields have rustdoc
13. - [ ] Indexing conventions clearly documented

## Tasks / Subtasks

- [ ] Create `Match` struct in `src/lib.rs` (AC: 1, 2, 3)
  - [ ] Define `start_line: usize` (1-indexed)
  - [ ] Define `end_line: usize` (1-indexed, inclusive)
  - [ ] Define `start_column: usize` (0-indexed)
  - [ ] Define `end_column: usize` (0-indexed)
  - [ ] Define `byte_range: std::ops::Range<usize>`
  - [ ] Define `text: String`
- [ ] Implement helper methods (AC: 8, 9, 10, 11)
  - [ ] `line_count()`
  - [ ] `is_multiline()`
  - [ ] `byte_len()`
  - [ ] `first_line()`
- [ ] Add rustdoc documentation (AC: 12, 13)
  - [ ] Document indexing conventions for each field
  - [ ] Provide usage examples
- [ ] Write unit tests for all methods

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 3]

### Complete Implementation

```rust
/// A single match within a file
///
/// Contains precise location information and the matched text content.
/// Line numbers are 1-indexed (matching editor conventions), while
/// columns and byte ranges are 0-indexed.
///
/// # Example
///
/// ```rust
/// let m: Match = /* from search result */;
///
/// println!("Match at lines {}-{}", m.start_line, m.end_line);
/// println!("Spans {} lines", m.line_count());
///
/// // Get the first line of matched text
/// let first_line = m.text.lines().next().unwrap_or("");
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Match {
    /// Start line number (1-indexed)
    pub start_line: usize,

    /// End line number (1-indexed, inclusive)
    pub end_line: usize,

    /// Start column (0-indexed byte offset within line)
    pub start_column: usize,

    /// End column (0-indexed byte offset within line)
    pub end_column: usize,

    /// Byte range within the file (0-indexed)
    pub byte_range: std::ops::Range<usize>,

    /// The matched text content
    pub text: String,
}

impl Match {
    /// Returns the number of lines this match spans
    ///
    /// A single-line match returns 1.
    pub fn line_count(&self) -> usize {
        self.end_line - self.start_line + 1
    }

    /// Returns true if this match spans multiple lines
    pub fn is_multiline(&self) -> bool {
        self.start_line != self.end_line
    }

    /// Get the byte length of the match
    pub fn byte_len(&self) -> usize {
        self.byte_range.len()
    }

    /// Get the first line of matched text
    pub fn first_line(&self) -> &str {
        self.text.lines().next().unwrap_or("")
    }
}
```

### Why 1-indexed lines but 0-indexed columns?
- Line numbers: 1-indexed matches editor conventions (VSCode, vim, etc.)
- Columns: 0-indexed because they're byte offsets, and tree-sitter uses 0-indexed columns
- Byte ranges: 0-indexed because they're direct file offsets

### Conversion from tree-sitter Range

When converting from tree-sitter `Range` to the `Match` struct, you need to adjust the line numbers from 0-indexed to 1-indexed:

```rust
// tree-sitter Range has 0-indexed rows
let ts_range: tree_sitter::Range = /* from evaluator */;

let match_struct = Match {
    start_line: ts_range.start_point.row + 1,  // 0 → 1 indexed
    end_line: ts_range.end_point.row + 1,      // 0 → 1 indexed
    start_column: ts_range.start_point.column, // stays 0-indexed
    end_column: ts_range.end_point.column,     // stays 0-indexed
    byte_range: ts_range.start_byte..ts_range.end_byte,
    text: content[ts_range.start_byte..ts_range.end_byte].to_string(),
};
```

### Testing

**Test Location:** Unit tests in `src/lib.rs`

**Test Cases:**
- `line_count()` for single-line and multi-line matches
- `is_multiline()` returns correct boolean
- `first_line()` extracts first line correctly
- Indexing convention documentation accuracy
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_line_count_single_line() {
        let m = Match {
            start_line: 5,
            end_line: 5,
            start_column: 0,
            end_column: 10,
            byte_range: 0..10,
            text: "fn main()".to_string(),
        };
        assert_eq!(m.line_count(), 1);
    }

    #[test]
    fn test_line_count_multi_line() {
        let m = Match {
            start_line: 1,
            end_line: 10,
            start_column: 0,
            end_column: 1,
            byte_range: 0..100,
            text: "...".to_string(),
        };
        assert_eq!(m.line_count(), 10);
    }

    #[test]
    fn test_is_multiline_false() {
        let m = Match {
            start_line: 3,
            end_line: 3,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert!(!m.is_multiline());
    }

    #[test]
    fn test_is_multiline_true() {
        let m = Match {
            start_line: 3,
            end_line: 5,
            start_column: 0,
            end_column: 5,
            byte_range: 0..50,
            text: "line1\nline2\nline3".to_string(),
        };
        assert!(m.is_multiline());
    }

    #[test]
    fn test_byte_len() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 12,
            byte_range: 10..22,
            text: "fn main() {}".to_string(),
        };
        assert_eq!(m.byte_len(), 12);
    }

    #[test]
    fn test_first_line_single() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 12,
            byte_range: 0..12,
            text: "fn main() {}".to_string(),
        };
        assert_eq!(m.first_line(), "fn main() {}");
    }

    #[test]
    fn test_first_line_multi() {
        let m = Match {
            start_line: 1,
            end_line: 3,
            start_column: 0,
            end_column: 1,
            byte_range: 0..30,
            text: "fn main() {\n    println!(\"hi\");\n}".to_string(),
        };
        assert_eq!(m.first_line(), "fn main() {");
    }

    #[test]
    fn test_first_line_empty() {
        let m = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 0,
            byte_range: 0..0,
            text: "".to_string(),
        };
        assert_eq!(m.first_line(), "");
    }

    #[test]
    fn test_match_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<Match>();
    }

    #[test]
    fn test_match_equality() {
        let m1 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        let m2 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert_eq!(m1, m2);
    }

    #[test]
    fn test_match_inequality() {
        let m1 = Match {
            start_line: 1,
            end_line: 1,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        let m2 = Match {
            start_line: 2,
            end_line: 2,
            start_column: 0,
            end_column: 5,
            byte_range: 0..5,
            text: "hello".to_string(),
        };
        assert_ne!(m1, m2);
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
