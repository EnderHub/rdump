# Story 1.8: Handle Iterator Edge Cases

## Status
Draft

## Story
**As a** library user,
**I want** all edge cases handled in the iterator (whole-file matches, Unicode, large files, missing files),
**so that** the library is robust and provides clear error messages for all scenarios.

## Acceptance Criteria

**Whole-File Matches:**
1. - [ ] Empty ranges vector results in empty matches
2. - [ ] `is_whole_file_match()` returns true for empty matches
3. - [ ] Content is still loaded and available

**File Size Limits:**
4. - [ ] Files over 10MB return error (configurable)
5. - [ ] Error message includes file size and limit
6. - [ ] Small files process normally

**Missing Files:**
7. - [ ] Deleted files return descriptive error
8. - [ ] Error includes file path
9. - [ ] Iterator continues to next file

**Unicode Handling:**
10. - [ ] Valid UTF-8 files work correctly
11. - [ ] Invalid UTF-8 returns error with file path
12. - [ ] Multi-byte characters in matches work correctly

**Permission Errors:**
13. - [ ] Unreadable files return error
14. - [ ] Error is descriptive
15. - [ ] Iterator continues to next file

## Tasks / Subtasks

- [ ] Handle whole-file matches (AC: 1, 2, 3)
  - [ ] Check for empty ranges vector
  - [ ] Set matches to empty vec for whole-file match
  - [ ] Ensure content is still loaded
- [ ] Add large file protection (AC: 4, 5, 6)
  - [ ] Define MAX_FILE_SIZE constant (10 MB)
  - [ ] Check file size before reading
  - [ ] Return descriptive error for oversized files
- [ ] Handle missing/deleted files (AC: 7, 8, 9)
  - [ ] Check for NotFound error kind
  - [ ] Return error with "no longer exists" message
- [ ] Handle binary file detection
  - [ ] Check for null bytes in first 8KB
  - [ ] Return error for binary files
- [ ] Handle permission errors (AC: 13, 14, 15)
  - [ ] Check for PermissionDenied error kind
  - [ ] Return descriptive error
- [ ] Write tests for all edge cases

## Dev Notes

### Location
- Primary file: `src/lib.rs` (SearchResultIterator implementation)
- [Source: docs/epics/library-api-epic.md - Story 8]

### Complete Implementation

#### 8.1 Whole-File Matches

```rust
// In SearchResultIterator::next()
let (path, ranges) = self.inner.next()?;

let content = std::fs::read_to_string(&path)?;

// Empty ranges = whole-file match (boolean predicate like ext:rs)
let matches = if ranges.is_empty() {
    vec![]  // Empty matches vector signals whole-file match
} else {
    ranges_to_matches(&content, &ranges)
};

// Users check with:
if result.is_whole_file_match() {
    // Entire file matched (e.g., ext:rs, lang:python)
}
```

#### 8.2 Large File Protection

```rust
const MAX_FILE_SIZE: u64 = 10 * 1024 * 1024; // 10 MB

fn read_file_content(path: &Path) -> Result<String> {
    let metadata = std::fs::metadata(path)?;

    if metadata.len() > MAX_FILE_SIZE {
        return Err(anyhow::anyhow!(
            "File {} exceeds maximum size limit ({} bytes > {} bytes)",
            path.display(),
            metadata.len(),
            MAX_FILE_SIZE
        ));
    }

    std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read {}", path.display()))
}
```

#### 8.3 Missing/Deleted Files

```rust
// In SearchResultIterator::next()
fn next(&mut self) -> Option<Self::Item> {
    let (path, ranges) = self.inner.next()?;

    // File may have been deleted between search and iteration
    let content = match std::fs::read_to_string(&path) {
        Ok(c) => c,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Some(Err(anyhow::anyhow!(
                "File no longer exists: {}",
                path.display()
            )));
        }
        Err(e) => {
            return Some(Err(anyhow::anyhow!(
                "Failed to read {}: {}",
                path.display(),
                e
            )));
        }
    };

    // ... rest of conversion
}
```

#### 8.4 Binary File Detection

```rust
fn is_likely_binary(content: &[u8]) -> bool {
    // Check first 8KB for null bytes
    let check_len = content.len().min(8192);
    content[..check_len].contains(&0)
}

// In iterator, optionally skip binary files:
let bytes = std::fs::read(&path)?;
if is_likely_binary(&bytes) {
    return Some(Err(anyhow::anyhow!(
        "Skipping binary file: {}",
        path.display()
    )));
}
let content = String::from_utf8(bytes)
    .map_err(|e| anyhow::anyhow!("Invalid UTF-8 in {}: {}", path.display(), e))?;
```

#### 8.5 Permission Errors

```rust
Err(e) if e.kind() == std::io::ErrorKind::PermissionDenied => {
    return Some(Err(anyhow::anyhow!(
        "Permission denied reading: {}",
        path.display()
    )));
}
```

### Error Recovery Strategy
The iterator returns `Result<SearchResult>` for each item, allowing users to:
1. Fail fast: `.collect::<Result<Vec<_>, _>>()?`
2. Skip errors: `.filter_map(Result::ok)`
3. Log and continue: `.map(|r| r.map_err(|e| eprintln!("{}", e)).ok())`

### Why Not Skip Errors Silently?
Returning errors gives users control. Some want to know about permission issues, others want to skip them. The library shouldn't make that decision.

### Complete Test Cases

**Test Location:** `tests/library_api.rs`

```rust
#[test]
fn test_whole_file_match() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].is_whole_file_match());
    assert!(results[0].matches.is_empty());
    assert!(!results[0].content.is_empty());  // Content still loaded
}

#[test]
fn test_missing_file_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete file after search but before iteration
    fs::remove_file(&file).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("no longer exists"));
}

#[test]
fn test_unicode_content() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("unicode.rs");
    fs::write(&file, "fn ä½ å¥½() { let Ã©moji = 'ðŸ¦€'; }").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].content.contains("ä½ å¥½"));
    assert!(results[0].content.contains("ðŸ¦€"));
}

#[test]
fn test_multiline_match() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {\n    println!(\"hello\");\n}").unwrap();

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let m = &results[0].matches[0];
    assert_eq!(m.start_line, 1);
    assert_eq!(m.end_line, 3);
    assert_eq!(m.line_count(), 3);
    assert!(m.is_multiline());
}

#[test]
fn test_large_file_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("large.rs");

    // Create a file larger than MAX_FILE_SIZE
    let large_content = "x".repeat(11 * 1024 * 1024); // 11 MB
    fs::write(&file, large_content).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("exceeds maximum size"));
}

#[test]
fn test_binary_file_detection() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("binary.rs");

    // Create a file with null bytes (binary indicator)
    let mut content = b"fn main() {}\x00binary data".to_vec();
    fs::write(&file, content).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("binary"));
}

#[test]
fn test_invalid_utf8_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("invalid.rs");

    // Write invalid UTF-8 bytes
    fs::write(&file, &[0xFF, 0xFE, 0x00, 0x01]).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("UTF-8"));
}

#[test]
fn test_continue_after_error() {
    let dir = tempdir().unwrap();

    // Create one good file and one that will be deleted
    let good_file = dir.path().join("good.rs");
    let bad_file = dir.path().join("bad.rs");
    fs::write(&good_file, "fn good() {}").unwrap();
    fs::write(&bad_file, "fn bad() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete one file
    fs::remove_file(&bad_file).unwrap();

    // Iterator should yield both an error and a success
    let results: Vec<_> = iter.collect();
    let successes: Vec<_> = results.iter().filter(|r| r.is_ok()).collect();
    let errors: Vec<_> = results.iter().filter(|r| r.is_err()).collect();

    assert_eq!(successes.len(), 1);
    assert_eq!(errors.len(), 1);
}

#[test]
fn test_empty_file() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("empty.rs");
    fs::write(&file, "").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].content.is_empty());
}
```

### Edge Case Handling Summary

| Edge Case | Behavior | Error Message |
|-----------|----------|---------------|
| Whole-file match | Empty matches vec | N/A (success) |
| File > 10MB | Return error | "exceeds maximum size limit" |
| File deleted | Return error | "no longer exists" |
| Permission denied | Return error | "Permission denied reading" |
| Invalid UTF-8 | Return error | "Invalid UTF-8 in" |
| Binary file | Return error | "Skipping binary file" |
| Empty file | Return success | N/A (empty content) |

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
