# Story 1.8: Handle Iterator Edge Cases

## Status
Done

## Story
**As a** library user,
**I want** all edge cases handled in the iterator (whole-file matches, Unicode, large files, missing files),
**so that** the library is robust and provides clear error messages for all scenarios.

## Acceptance Criteria

**Whole-File Matches:**
1. - [x] Empty ranges vector results in empty matches
2. - [x] `is_whole_file_match()` returns true for empty matches
3. - [x] Content is still loaded and available

**File Size Limits:**
4. - [x] Files over 10MB return error (configurable)
5. - [x] Error message includes file size and limit
6. - [x] Small files process normally

**Missing Files:**
7. - [x] Deleted files return descriptive error
8. - [x] Error includes file path
9. - [x] Iterator continues to next file

**Unicode Handling:**
10. - [x] Valid UTF-8 files work correctly
11. - [x] Invalid UTF-8 returns error with file path
12. - [x] Multi-byte characters in matches work correctly

**Permission Errors:**
13. - [x] Unreadable files return error
14. - [x] Error is descriptive
15. - [x] Iterator continues to next file

## Tasks / Subtasks

- [x] Handle whole-file matches (AC: 1, 2, 3)
  - [x] Check for empty ranges vector
  - [x] Set matches to empty vec for whole-file match
  - [x] Ensure content is still loaded
- [x] Add large file protection (AC: 4, 5, 6)
  - [x] Define MAX_FILE_SIZE constant (10 MB)
  - [x] Check file size before reading
  - [x] Return descriptive error for oversized files
- [x] Handle missing/deleted files (AC: 7, 8, 9)
  - [x] Check for NotFound error kind
  - [x] Return error with "no longer exists" message
- [x] Handle binary file detection
  - [x] Check for null bytes in first 8KB
  - [x] Return error for binary files
- [x] Handle permission errors (AC: 13, 14, 15)
  - [x] Check for PermissionDenied error kind
  - [x] Return descriptive error
- [x] Write tests for all edge cases

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `read_file_content_for_iterator` with size guard (10 MB limit), binary detection, UTF-8 validation, and descriptive errors for missing or permission-denied files.
  - Updated `SearchResultIterator` to treat empty ranges as whole-file matches while still loading content.
  - Expanded unit tests to cover whole-file matches, size limit failures, missing files, permission errors, binary detection, invalid UTF-8, multibyte Unicode ranges, and iterator continuation after errors.
  - `cargo test --lib` passes; full `cargo test` still hits preset tests requiring write access to global config (`/Users/alm/Library/Application Support/rdump/config.toml`).
- File List:
  - rdump/src/lib.rs

## Dev Notes

### Location
- Primary file: `src/lib.rs` (SearchResultIterator implementation)
- [Source: docs/epics/library-api-epic.md - Story 8]

### Complete Implementation

#### 8.1 Whole-File Matches

```rust
// In SearchResultIterator::next()
let (path, ranges) = self.inner.next()?;

let content = std::fs::read_to_string(&path)?;

// Empty ranges = whole-file match (boolean predicate like ext:rs)
let matches = if ranges.is_empty() {
    vec![]  // Empty matches vector signals whole-file match
} else {
    ranges_to_matches(&content, &ranges)
};

// Users check with:
if result.is_whole_file_match() {
    // Entire file matched (e.g., ext:rs, lang:python)
}
```

#### 8.2 Large File Protection

```rust
const MAX_FILE_SIZE: u64 = 10 * 1024 * 1024; // 10 MB

fn read_file_content(path: &Path) -> Result<String> {
    let metadata = std::fs::metadata(path)?;

    if metadata.len() > MAX_FILE_SIZE {
        return Err(anyhow::anyhow!(
            "File {} exceeds maximum size limit ({} bytes > {} bytes)",
            path.display(),
            metadata.len(),
            MAX_FILE_SIZE
        ));
    }

    std::fs::read_to_string(path)
        .with_context(|| format!("Failed to read {}", path.display()))
}
```

#### 8.3 Missing/Deleted Files

```rust
// In SearchResultIterator::next()
fn next(&mut self) -> Option<Self::Item> {
    let (path, ranges) = self.inner.next()?;

    // File may have been deleted between search and iteration
    let content = match std::fs::read_to_string(&path) {
        Ok(c) => c,
        Err(e) if e.kind() == std::io::ErrorKind::NotFound => {
            return Some(Err(anyhow::anyhow!(
                "File no longer exists: {}",
                path.display()
            )));
        }
        Err(e) => {
            return Some(Err(anyhow::anyhow!(
                "Failed to read {}: {}",
                path.display(),
                e
            )));
        }
    };

    // ... rest of conversion
}
```

#### 8.4 Binary File Detection

```rust
fn is_likely_binary(content: &[u8]) -> bool {
    // Check first 8KB for null bytes
    let check_len = content.len().min(8192);
    content[..check_len].contains(&0)
}

// In iterator, optionally skip binary files:
let bytes = std::fs::read(&path)?;
if is_likely_binary(&bytes) {
    return Some(Err(anyhow::anyhow!(
        "Skipping binary file: {}",
        path.display()
    )));
}
let content = String::from_utf8(bytes)
    .map_err(|e| anyhow::anyhow!("Invalid UTF-8 in {}: {}", path.display(), e))?;
```

#### 8.5 Permission Errors

```rust
Err(e) if e.kind() == std::io::ErrorKind::PermissionDenied => {
    return Some(Err(anyhow::anyhow!(
        "Permission denied reading: {}",
        path.display()
    )));
}
```

### Error Recovery Strategy
The iterator returns `Result<SearchResult>` for each item, allowing users to:
1. Fail fast: `.collect::<Result<Vec<_>, _>>()?`
2. Skip errors: `.filter_map(Result::ok)`
3. Log and continue: `.map(|r| r.map_err(|e| eprintln!("{}", e)).ok())`

### Why Not Skip Errors Silently?
Returning errors gives users control. Some want to know about permission issues, others want to skip them. The library shouldn't make that decision.

### Complete Test Cases

**Test Location:** `tests/library_api.rs`

```rust
#[test]
fn test_whole_file_match() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].is_whole_file_match());
    assert!(results[0].matches.is_empty());
    assert!(!results[0].content.is_empty());  // Content still loaded
}

#[test]
fn test_missing_file_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete file after search but before iteration
    fs::remove_file(&file).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("no longer exists"));
}

#[test]
fn test_unicode_content() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("unicode.rs");
    fs::write(&file, "fn ä½ å¥½() { let Ã©moji = 'ðŸ¦€'; }").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].content.contains("ä½ å¥½"));
    assert!(results[0].content.contains("ðŸ¦€"));
}

#[test]
fn test_multiline_match() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("test.rs");
    fs::write(&file, "fn main() {\n    println!(\"hello\");\n}").unwrap();

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let m = &results[0].matches[0];
    assert_eq!(m.start_line, 1);
    assert_eq!(m.end_line, 3);
    assert_eq!(m.line_count(), 3);
    assert!(m.is_multiline());
}

#[test]
fn test_large_file_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("large.rs");

    // Create a file larger than MAX_FILE_SIZE
    let large_content = "x".repeat(11 * 1024 * 1024); // 11 MB
    fs::write(&file, large_content).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("exceeds maximum size"));
}

#[test]
fn test_binary_file_detection() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("binary.rs");

    // Create a file with null bytes (binary indicator)
    let mut content = b"fn main() {}\x00binary data".to_vec();
    fs::write(&file, content).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("binary"));
}

#[test]
fn test_invalid_utf8_error() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("invalid.rs");

    // Write invalid UTF-8 bytes
    fs::write(&file, &[0xFF, 0xFE, 0x00, 0x01]).unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    let result = iter.next().unwrap();
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("UTF-8"));
}

#[test]
fn test_continue_after_error() {
    let dir = tempdir().unwrap();

    // Create one good file and one that will be deleted
    let good_file = dir.path().join("good.rs");
    let bad_file = dir.path().join("bad.rs");
    fs::write(&good_file, "fn good() {}").unwrap();
    fs::write(&bad_file, "fn bad() {}").unwrap();

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    // Delete one file
    fs::remove_file(&bad_file).unwrap();

    // Iterator should yield both an error and a success
    let results: Vec<_> = iter.collect();
    let successes: Vec<_> = results.iter().filter(|r| r.is_ok()).collect();
    let errors: Vec<_> = results.iter().filter(|r| r.is_err()).collect();

    assert_eq!(successes.len(), 1);
    assert_eq!(errors.len(), 1);
}

#[test]
fn test_empty_file() {
    let dir = tempdir().unwrap();
    let file = dir.path().join("empty.rs");
    fs::write(&file, "").unwrap();

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).unwrap();

    assert_eq!(results.len(), 1);
    assert!(results[0].content.is_empty());
}
```

### Edge Case Handling Summary

| Edge Case | Behavior | Error Message |
|-----------|----------|---------------|
| Whole-file match | Empty matches vec | N/A (success) |
| File > 10MB | Return error | "exceeds maximum size limit" |
| File deleted | Return error | "no longer exists" |
| Permission denied | Return error | "Permission denied reading" |
| Invalid UTF-8 | Return error | "Invalid UTF-8 in" |
| Binary file | Return error | "Skipping binary file" |
| Empty file | Return success | N/A (empty content) |

### Technical Notes
- [Source: docs/architecture.md#test-strategy]

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Implementation provides comprehensive edge case handling with clear, descriptive error messages. The `read_file_content_for_iterator` helper centralizes all validation logic cleanly.

**Implementation Highlights:**
- Dedicated `read_file_content_for_iterator` function handles all edge cases
- Error messages include file paths for debugging
- Match on `ErrorKind` for specific error types (NotFound, PermissionDenied)
- Binary detection checks first 8KB for null bytes
- UTF-8 validation with `String::from_utf8`
- File size check before reading to avoid memory issues
- Iterator continues after errors (returns `Some(Err(...))`)

**Code Location:** `rdump/src/lib.rs:368-403` (read_file_content_for_iterator)

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: âœ“ No unwrap() on user data, all errors include path context
- Project Structure: âœ“ Code is in correct location (src/lib.rs)
- Testing Strategy: âœ“ All 7 edge case tests pass
- All ACs Met: âœ“ All 15 acceptance criteria verified

### Improvements Checklist

**Whole-File Matches:**
- [x] Empty ranges vector results in empty matches (lines 437-441)
- [x] is_whole_file_match() returns true for empty matches
- [x] Content is still loaded and available

**File Size Limits:**
- [x] Files over 10MB return error (lines 377-384)
- [x] Error message includes file size and limit
- [x] Small files process normally

**Missing Files:**
- [x] Deleted files return descriptive error (lines 370, 387)
- [x] Error includes file path
- [x] Iterator continues to next file

**Unicode Handling:**
- [x] Valid UTF-8 files work correctly (line 399)
- [x] Invalid UTF-8 returns error with file path (lines 399-400)
- [x] Multi-byte characters handled correctly

**Permission Errors:**
- [x] Unreadable files return error (lines 371-373, 388-390)
- [x] Error is descriptive
- [x] Iterator continues to next file

### Security Review

No security concerns - proper size limits prevent memory exhaustion, binary detection prevents processing inappropriate files.

### Performance Considerations

**Efficient implementation:**
- File size check before reading avoids loading large files into memory
- Binary detection only checks first 8KB
- Errors returned immediately without processing further

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS â†’ docs/qa/gates/1.8-handle-iterator-edge-cases.yml

### Recommended Status

âœ“ Ready for Done

All 15 acceptance criteria have been met, all 7 tests pass, and the implementation provides robust edge case handling with clear error messages.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 1.0 | Implemented iterator edge-case handling, errors, and tests | Dev Agent |
