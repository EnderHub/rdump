# Story 1.2: Create SearchResult Struct

## Status
Draft

## Story
**As a** library user,
**I want** a `SearchResult` struct with helper methods for working with matches,
**so that** I can easily process search results and access file content and match information.

## Acceptance Criteria

1. - [ ] Struct derives `Debug`, `Clone`
2. - [ ] Struct is `Send + Sync`
3. - [ ] All fields use owned types
4. - [ ] `is_whole_file_match()` returns true when `matches.is_empty()`
5. - [ ] `matched_lines()` returns sorted, deduplicated 1-indexed line numbers
6. - [ ] `match_count()` returns `matches.len()`
7. - [ ] `total_lines_matched()` returns count of unique lines
8. - [ ] Struct has rustdoc with example
9. - [ ] Each field and method has `///` documentation
10. - [ ] Example shows both whole-file and hunk matching patterns

## Tasks / Subtasks

- [ ] Create `SearchResult` struct in `src/lib.rs` (AC: 1, 2, 3)
  - [ ] Define `path: PathBuf`
  - [ ] Define `matches: Vec<Match>`
  - [ ] Define `content: String`
- [ ] Implement `is_whole_file_match()` method (AC: 4)
- [ ] Implement `matched_lines()` method (AC: 5)
  - [ ] Flatten line ranges from all matches
  - [ ] Sort and deduplicate
- [ ] Implement `match_count()` method (AC: 6)
- [ ] Implement `total_lines_matched()` method (AC: 7)
- [ ] Add rustdoc documentation (AC: 8, 9, 10)
- [ ] Write unit tests for all helper methods

## Dev Notes

### Location
- Primary file: `src/lib.rs`
- [Source: docs/epics/library-api-epic.md - Story 2]

### Complete Implementation

```rust
/// A file that matched the search query
///
/// Contains the file path, all matches within the file, and the file content.
/// For whole-file matches (boolean predicates like `ext:rs`), the `matches`
/// vector will be empty.
///
/// # Example
///
/// ```rust
/// let result: SearchResult = /* from search */;
///
/// if result.is_whole_file_match() {
///     println!("Whole file matched: {}", result.path.display());
/// } else {
///     for m in &result.matches {
///         println!("Lines {}-{}: {}", m.start_line, m.end_line, m.text);
///     }
/// }
/// ```
#[derive(Debug, Clone)]
pub struct SearchResult {
    /// Path to the matched file
    pub path: PathBuf,

    /// Matches within this file (empty for whole-file matches)
    pub matches: Vec<Match>,

    /// Full file content
    pub content: String,
}

impl SearchResult {
    /// Returns true if this is a whole-file match (no specific hunks)
    ///
    /// Whole-file matches occur with boolean predicates like `ext:rs` or
    /// `lang:python` that match the entire file rather than specific code blocks.
    pub fn is_whole_file_match(&self) -> bool {
        self.matches.is_empty()
    }

    /// Get all matched line numbers (1-indexed)
    ///
    /// Returns a sorted, deduplicated list of all line numbers that contain matches.
    pub fn matched_lines(&self) -> Vec<usize> {
        let mut lines: Vec<usize> = self.matches
            .iter()
            .flat_map(|m| m.start_line..=m.end_line)
            .collect();
        lines.sort_unstable();
        lines.dedup();
        lines
    }

    /// Get the number of matches in this file
    pub fn match_count(&self) -> usize {
        self.matches.len()
    }

    /// Get the total number of lines matched
    pub fn total_lines_matched(&self) -> usize {
        self.matched_lines().len()
    }
}
```

### Why empty matches = whole-file match
When the evaluator returns `MatchResult::Boolean(true)`, it means a boolean predicate matched (like `ext:rs`). There are no specific code hunks - the entire file is the match. We represent this as an empty `matches` vector rather than a single match spanning the whole file because:
1. It's more efficient (don't need to calculate file line count)
2. It clearly distinguishes "whole file matched" from "one big hunk matched"
3. Matches the internal `MatchResult` enum semantics

### Coding Standards
- [Source: docs/architecture.md#coding-standards]
- Never clone `FileContext` - use references only
- Content must be valid UTF-8 - skip binary files

### Testing

**Test Location:** Unit tests in `src/lib.rs`

**Test Cases:**
- `is_whole_file_match()` with empty and non-empty matches
- `matched_lines()` returns sorted, deduplicated results
- `match_count()` and `total_lines_matched()` accuracy
- [Source: docs/architecture.md#test-strategy]

#### Test Code

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_is_whole_file_match_empty() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![],
            content: "fn main() {}".to_string(),
        };
        assert!(result.is_whole_file_match());
    }

    #[test]
    fn test_is_whole_file_match_with_matches() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![
                Match {
                    start_line: 1,
                    end_line: 1,
                    start_column: 0,
                    end_column: 12,
                    byte_range: 0..12,
                    text: "fn main() {}".to_string(),
                }
            ],
            content: "fn main() {}".to_string(),
        };
        assert!(!result.is_whole_file_match());
    }

    #[test]
    fn test_matched_lines_single_match() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![
                Match {
                    start_line: 5,
                    end_line: 7,
                    start_column: 0,
                    end_column: 1,
                    byte_range: 0..100,
                    text: "...".to_string(),
                }
            ],
            content: "...".to_string(),
        };
        assert_eq!(result.matched_lines(), vec![5, 6, 7]);
    }

    #[test]
    fn test_matched_lines_overlapping() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![
                Match {
                    start_line: 1,
                    end_line: 3,
                    start_column: 0,
                    end_column: 1,
                    byte_range: 0..50,
                    text: "...".to_string(),
                },
                Match {
                    start_line: 2,
                    end_line: 4,
                    start_column: 0,
                    end_column: 1,
                    byte_range: 25..100,
                    text: "...".to_string(),
                }
            ],
            content: "...".to_string(),
        };
        // Should be deduplicated: 1, 2, 3, 4
        assert_eq!(result.matched_lines(), vec![1, 2, 3, 4]);
    }

    #[test]
    fn test_matched_lines_empty_matches() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![],
            content: "...".to_string(),
        };
        assert_eq!(result.matched_lines(), Vec::<usize>::new());
    }

    #[test]
    fn test_match_count() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![
                Match {
                    start_line: 1,
                    end_line: 1,
                    start_column: 0,
                    end_column: 5,
                    byte_range: 0..5,
                    text: "fn a()".to_string(),
                },
                Match {
                    start_line: 3,
                    end_line: 3,
                    start_column: 0,
                    end_column: 5,
                    byte_range: 10..15,
                    text: "fn b()".to_string(),
                }
            ],
            content: "...".to_string(),
        };
        assert_eq!(result.match_count(), 2);
    }

    #[test]
    fn test_total_lines_matched() {
        let result = SearchResult {
            path: PathBuf::from("test.rs"),
            matches: vec![
                Match {
                    start_line: 1,
                    end_line: 3,
                    start_column: 0,
                    end_column: 1,
                    byte_range: 0..50,
                    text: "...".to_string(),
                },
                Match {
                    start_line: 5,
                    end_line: 5,
                    start_column: 0,
                    end_column: 1,
                    byte_range: 60..70,
                    text: "...".to_string(),
                }
            ],
            content: "...".to_string(),
        };
        // Lines 1, 2, 3, 5 = 4 total
        assert_eq!(result.total_lines_matched(), 4);
    }

    #[test]
    fn test_search_result_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<SearchResult>();
    }
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
