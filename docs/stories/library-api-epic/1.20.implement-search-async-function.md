# Story 1.20: Implement search_async Function

## Status
Done

## Story
**As a** library user in an async application,
**I want** an async streaming search function,
**so that** I can use rdump in tokio-based applications while preserving rayon's parallelism.

## Acceptance Criteria

**Function Signature:**
1. - [x] Returns `Result<impl Stream<Item = Result<SearchResult>>>`
2. - [x] Takes `&str` query and owned `SearchOptions`
3. - [x] Feature-gated with `#[cfg(feature = "async")]`

**Implementation:**
4. - [x] Uses `spawn_blocking` for sync-to-async bridge
5. - [x] Bounded channel (100 items) for backpressure
6. - [x] Early termination when stream is dropped
7. - [x] Error handling for search failures

**Documentation:**
8. - [x] Full rustdoc with examples
9. - [x] Documents backpressure behavior
10. - [x] Documents early termination
11. - [x] Shows common usage patterns

**Testing:**
12. - [x] Basic streaming works
13. - [x] Early termination stops producer
14. - [x] Errors are propagated correctly
15. - [x] Works with tokio runtime

## Tasks / Subtasks

- [x] Create `src/async_api.rs` module
- [x] Implement `search_async` function (AC: 1, 2, 3)
  - [x] Create bounded mpsc channel
  - [x] Spawn blocking task for search
  - [x] Stream results via ReceiverStream
- [x] Implement backpressure mechanism (AC: 4, 5)
  - [x] Use `blocking_send` in producer
  - [x] Channel size of 100 items
- [x] Handle early termination (AC: 6)
  - [x] Check send result for receiver drop
  - [x] Break out of loop on error
- [x] Handle errors (AC: 7)
  - [x] Send errors through channel
  - [x] Handle search_iter failure
- [x] Add rustdoc documentation (AC: 8, 9, 10, 11)
- [x] Write tests (AC: 12, 13, 14, 15)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Implemented `search_async` in `rdump/src/async_api.rs` (feature-gated) using `spawn_blocking` + bounded mpsc (100) and `ReceiverStream`; documents backpressure and early termination with examples.
  - Exported `search_async` from `lib.rs` under `#[cfg(feature = "async")]`.
  - Added async tests (`rdump/tests/async_api.rs`) for basic streaming, early termination, and error propagation (tokio runtime).
  - Verified builds/tests offline: `cargo test --features async --offline` (includes doc test in async_api), and prior sync builds/tests also passing offline.
- File List:
  - rdump/src/async_api.rs
  - rdump/src/lib.rs
  - rdump/tests/async_api.rs

## Dev Notes

### Location
- Primary file: `src/async_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 20]

### Why spawn_blocking?
The search uses rayon for parallelism, which is incompatible with async. Using `spawn_blocking`:
1. Runs search on tokio's blocking thread pool
2. Preserves rayon's parallel file evaluation
3. Bridges sync results to async stream via channel

### Backpressure Mechanism
```
Producer (spawn_blocking)  →  Channel (100)  →  Consumer (async)
         ↓                                         ↓
    blocking_send()                             stream.next()
         ↓                                         ↓
    Blocks if full                             Wakes producer
```

If consumer is slow, channel fills up and producer blocks on `blocking_send()`.

### Memory Usage
- Channel buffer: 100 × (SearchResult size)
- Each SearchResult includes file content
- Bounded channel prevents unbounded memory growth

### Channel Size Trade-offs
| Size | Pro | Con |
|------|-----|-----|
| Small (10) | Lower memory | More blocking |
| Medium (100) | Balanced | Default choice |
| Large (1000) | Less blocking | Higher memory |

### Complete Implementation

#### src/async_api.rs

```rust
//! Async API for rdump search
//!
//! This module provides async versions of the search functions for use
//! in tokio-based applications.

use crate::{search_iter, SearchOptions, SearchResult};
use anyhow::Result;
use futures::Stream;
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;

/// Search for files matching a query (async streaming)
///
/// Returns a Stream that yields results one at a time. The search runs
/// in a blocking thread pool (via `spawn_blocking`) to preserve rayon's
/// parallelism while being async-friendly.
///
/// # Arguments
///
/// * `query` - An RQL query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// A stream yielding `Result<SearchResult>` for each matching file.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - The blocking task fails to spawn
///
/// # Backpressure
///
/// The channel has a bounded capacity (100 items). If the consumer is slow,
/// the producer will block, providing natural backpressure.
///
/// # Example
///
/// ```rust
/// use rdump::{search_async, SearchOptions};
/// use futures::StreamExt;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let mut stream = search_async("ext:rs", SearchOptions::default()).await?;
///
///     while let Some(result) = stream.next().await {
///         let result = result?;
///         println!("{}", result.path.display());
///     }
///
///     Ok(())
/// }
/// ```
///
/// # Early Termination
///
/// Dropping the stream will signal the producer to stop:
///
/// ```rust
/// # use rdump::{search_async, SearchOptions};
/// # use futures::StreamExt;
/// # async fn example() -> anyhow::Result<()> {
/// let stream = search_async("ext:rs", SearchOptions::default()).await?;
///
/// // Take only first 10
/// let first_ten: Vec<_> = stream
///     .take(10)
///     .collect::<Vec<_>>()
///     .await
///     .into_iter()
///     .collect::<Result<Vec<_>, _>>()?;
/// # Ok(())
/// # }
/// ```
pub async fn search_async(
    query: &str,
    options: SearchOptions,
) -> Result<impl Stream<Item = Result<SearchResult>>> {
    // Clone query for move into blocking task
    let query = query.to_string();

    // Bounded channel for backpressure
    let (tx, rx) = mpsc::channel(100);

    // Spawn blocking task for the sync search
    tokio::task::spawn_blocking(move || {
        // Perform the search (uses rayon parallelism internally)
        let iter = match search_iter(&query, options) {
            Ok(iter) => iter,
            Err(e) => {
                // Send error and return
                let _ = tx.blocking_send(Err(e));
                return;
            }
        };

        // Stream results through the channel
        for result in iter {
            // If receiver is dropped, stop sending
            if tx.blocking_send(result).is_err() {
                break;
            }
        }
    });

    Ok(ReceiverStream::new(rx))
}
```

#### Alternative Implementation with Better Error Handling

```rust
/// More robust version with explicit error handling for spawn failures
pub async fn search_async_robust(
    query: &str,
    options: SearchOptions,
) -> Result<impl Stream<Item = Result<SearchResult>>> {
    let query = query.to_string();
    let (tx, rx) = mpsc::channel(100);

    let handle = tokio::task::spawn_blocking(move || {
        let iter = search_iter(&query, options)?;

        for result in iter {
            if tx.blocking_send(result).is_err() {
                // Receiver dropped, stop early
                break;
            }
        }

        Ok::<_, anyhow::Error>(())
    });

    // Spawn a task to check for panics in the blocking task
    let error_tx = tx.clone();
    tokio::spawn(async move {
        match handle.await {
            Ok(Ok(())) => {} // Success
            Ok(Err(e)) => {
                // Search error
                let _ = error_tx.send(Err(e)).await;
            }
            Err(e) => {
                // Panic in blocking task
                let _ = error_tx.send(Err(anyhow::anyhow!("Search task panicked: {}", e))).await;
            }
        }
    });

    Ok(ReceiverStream::new(rx))
}
```

### Example Usage

```rust
use rdump::{search_async, SearchOptions};
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

    while let Some(result) = stream.next().await {
        let result = result?;
        println!("{}", result.path.display());
    }

    Ok(())
}
```

### Testing

**Test Location:** `tests/async_api.rs`

**Test Cases:**
- Basic async streaming
- Early termination with `.take()`
- Drop stream stops producer
- Error propagation
- [Source: docs/architecture.md#test-strategy]

**Test Code:**
```rust
#[tokio::test]
async fn test_search_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let mut stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    let mut count = 0;
    while let Some(result) = stream.next().await {
        let result = result?;
        assert!(result.path.extension().unwrap() == "rs");
        count += 1;
    }

    assert_eq!(count, 2);
    Ok(())
}

#[tokio::test]
async fn test_search_async_early_termination() -> Result<()> {
    let dir = tempdir()?;

    // Create many files
    for i in 0..50 {
        fs::write(dir.path().join(format!("file{}.rs", i)), "fn main() {}")?;
    }

    let stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    // Take only first 5
    let first_five: Vec<_> = stream
        .take(5)
        .collect::<Vec<_>>()
        .await
        .into_iter()
        .collect::<Result<Vec<_>, _>>()?;

    assert_eq!(first_five.len(), 5);
    Ok(())
}
```

## QA Results

### Review Date: 2025-11-21

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall: Excellent** - Clean implementation of async streaming search using spawn_blocking and bounded channels. Properly feature-gated with comprehensive documentation including backpressure and early termination behavior.

**Implementation Highlights:**
- Function signature returns `Result<impl Stream<Item = Result<SearchResult>>>` (line 54)
- Uses `spawn_blocking` for sync-to-async bridge (line 58)
- Bounded channel with 100 items for backpressure (line 56)
- Early termination when receiver drops (lines 68-69)
- Error handling for search_iter failures (lines 59-65)
- Full rustdoc with # Arguments, # Returns, # Errors, # Examples (lines 13-50)

**Code Locations:**
- `rdump/src/async_api.rs` (lines 1-75)
- `rdump/src/lib.rs` (lines 52-53, 204-205)
- `rdump/tests/async_api.rs` (lines 1-70)

### Refactoring Performed

None required - implementation is clean and meets all requirements.

### Compliance Check

- Coding Standards: ✓ Clean async/await patterns
- Project Structure: ✓ Properly feature-gated module
- Testing Strategy: ✓ All 4 test scenarios covered
- All ACs Met: ✓ All 15 acceptance criteria verified

### Improvements Checklist

All items completed satisfactorily:

**Function Signature (3/3):**
- [x] Returns `Result<impl Stream<Item = Result<SearchResult>>>` (line 54)
- [x] Takes `&str` query and owned `SearchOptions` (lines 51-53)
- [x] Feature-gated with `#[cfg(feature = "async")]` (lib.rs lines 52-53, 204-205)

**Implementation (4/4):**
- [x] Uses `spawn_blocking` for sync-to-async bridge (line 58)
- [x] Bounded channel (100 items) for backpressure (line 56)
- [x] Early termination when stream is dropped (lines 68-69)
- [x] Error handling for search failures (lines 59-65)

**Documentation (4/4):**
- [x] Full rustdoc with examples (lines 13-50)
- [x] Documents backpressure behavior (lines 15-16)
- [x] Documents early termination (line 17)
- [x] Shows common usage patterns (lines 32-50)

**Testing (4/4):**
- [x] Basic streaming works (`test_search_async_basic_streaming`)
- [x] Early termination stops producer (`test_search_async_early_termination`)
- [x] Errors are propagated correctly (`test_search_async_propagates_error`)
- [x] Works with tokio runtime (all tests use `#[tokio::test]`)

### Test Results

| Test | Result |
|------|--------|
| `test_search_async_basic_streaming` | PASS |
| `test_search_async_early_termination` | PASS |
| `test_search_async_propagates_error` | PASS |
| Doc test (search_async) | PASS |

Total: 4 tests pass (3 integration + 1 doc test)

### Security Review

No security concerns - standard async patterns with proper channel bounds.

### Performance Considerations

**Async efficiency:**
- Bounded channel (100) provides backpressure
- spawn_blocking preserves rayon parallelism
- Early termination prevents wasted work

### Files Modified During Review

None - no modifications were necessary.

### Gate Status

Gate: PASS → docs/qa/gates/1.20-implement-search-async-function.yml

### Recommended Status

✓ Ready for Done

All 15 acceptance criteria have been met. The search_async function provides a clean async interface to the sync search while preserving rayon's parallelism.

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 0.2 | Implemented async streaming search with tests and docs | Dev Agent |
| 2025-11-21 | 1.0 | QA Review completed - all 15 ACs verified | Quinn (QA) |
