# Story 1.20: Implement search_async Function

## Status
Draft

## Story
**As a** library user in an async application,
**I want** an async streaming search function,
**so that** I can use rdump in tokio-based applications while preserving rayon's parallelism.

## Acceptance Criteria

**Function Signature:**
1. - [ ] Returns `Result<impl Stream<Item = Result<SearchResult>>>`
2. - [ ] Takes `&str` query and owned `SearchOptions`
3. - [ ] Feature-gated with `#[cfg(feature = "async")]`

**Implementation:**
4. - [ ] Uses `spawn_blocking` for sync-to-async bridge
5. - [ ] Bounded channel (100 items) for backpressure
6. - [ ] Early termination when stream is dropped
7. - [ ] Error handling for search failures

**Documentation:**
8. - [ ] Full rustdoc with examples
9. - [ ] Documents backpressure behavior
10. - [ ] Documents early termination
11. - [ ] Shows common usage patterns

**Testing:**
12. - [ ] Basic streaming works
13. - [ ] Early termination stops producer
14. - [ ] Errors are propagated correctly
15. - [ ] Works with tokio runtime

## Tasks / Subtasks

- [ ] Create `src/async_api.rs` module
- [ ] Implement `search_async` function (AC: 1, 2, 3)
  - [ ] Create bounded mpsc channel
  - [ ] Spawn blocking task for search
  - [ ] Stream results via ReceiverStream
- [ ] Implement backpressure mechanism (AC: 4, 5)
  - [ ] Use `blocking_send` in producer
  - [ ] Channel size of 100 items
- [ ] Handle early termination (AC: 6)
  - [ ] Check send result for receiver drop
  - [ ] Break out of loop on error
- [ ] Handle errors (AC: 7)
  - [ ] Send errors through channel
  - [ ] Handle search_iter failure
- [ ] Add rustdoc documentation (AC: 8, 9, 10, 11)
- [ ] Write tests (AC: 12, 13, 14, 15)

## Dev Notes

### Location
- Primary file: `src/async_api.rs`
- [Source: docs/epics/library-api-epic.md - Story 20]

### Why spawn_blocking?
The search uses rayon for parallelism, which is incompatible with async. Using `spawn_blocking`:
1. Runs search on tokio's blocking thread pool
2. Preserves rayon's parallel file evaluation
3. Bridges sync results to async stream via channel

### Backpressure Mechanism
```
Producer (spawn_blocking)  →  Channel (100)  →  Consumer (async)
         ↓                                         ↓
    blocking_send()                             stream.next()
         ↓                                         ↓
    Blocks if full                             Wakes producer
```

If consumer is slow, channel fills up and producer blocks on `blocking_send()`.

### Memory Usage
- Channel buffer: 100 × (SearchResult size)
- Each SearchResult includes file content
- Bounded channel prevents unbounded memory growth

### Channel Size Trade-offs
| Size | Pro | Con |
|------|-----|-----|
| Small (10) | Lower memory | More blocking |
| Medium (100) | Balanced | Default choice |
| Large (1000) | Less blocking | Higher memory |

### Complete Implementation

#### src/async_api.rs

```rust
//! Async API for rdump search
//!
//! This module provides async versions of the search functions for use
//! in tokio-based applications.

use crate::{search_iter, SearchOptions, SearchResult};
use anyhow::Result;
use futures::Stream;
use tokio::sync::mpsc;
use tokio_stream::wrappers::ReceiverStream;

/// Search for files matching a query (async streaming)
///
/// Returns a Stream that yields results one at a time. The search runs
/// in a blocking thread pool (via `spawn_blocking`) to preserve rayon's
/// parallelism while being async-friendly.
///
/// # Arguments
///
/// * `query` - An RQL query string
/// * `options` - Search configuration options
///
/// # Returns
///
/// A stream yielding `Result<SearchResult>` for each matching file.
///
/// # Errors
///
/// Returns an error if:
/// - The query syntax is invalid
/// - The root directory doesn't exist
/// - The blocking task fails to spawn
///
/// # Backpressure
///
/// The channel has a bounded capacity (100 items). If the consumer is slow,
/// the producer will block, providing natural backpressure.
///
/// # Example
///
/// ```rust
/// use rdump::{search_async, SearchOptions};
/// use futures::StreamExt;
///
/// #[tokio::main]
/// async fn main() -> anyhow::Result<()> {
///     let mut stream = search_async("ext:rs", SearchOptions::default()).await?;
///
///     while let Some(result) = stream.next().await {
///         let result = result?;
///         println!("{}", result.path.display());
///     }
///
///     Ok(())
/// }
/// ```
///
/// # Early Termination
///
/// Dropping the stream will signal the producer to stop:
///
/// ```rust
/// # use rdump::{search_async, SearchOptions};
/// # use futures::StreamExt;
/// # async fn example() -> anyhow::Result<()> {
/// let stream = search_async("ext:rs", SearchOptions::default()).await?;
///
/// // Take only first 10
/// let first_ten: Vec<_> = stream
///     .take(10)
///     .collect::<Vec<_>>()
///     .await
///     .into_iter()
///     .collect::<Result<Vec<_>, _>>()?;
/// # Ok(())
/// # }
/// ```
pub async fn search_async(
    query: &str,
    options: SearchOptions,
) -> Result<impl Stream<Item = Result<SearchResult>>> {
    // Clone query for move into blocking task
    let query = query.to_string();

    // Bounded channel for backpressure
    let (tx, rx) = mpsc::channel(100);

    // Spawn blocking task for the sync search
    tokio::task::spawn_blocking(move || {
        // Perform the search (uses rayon parallelism internally)
        let iter = match search_iter(&query, options) {
            Ok(iter) => iter,
            Err(e) => {
                // Send error and return
                let _ = tx.blocking_send(Err(e));
                return;
            }
        };

        // Stream results through the channel
        for result in iter {
            // If receiver is dropped, stop sending
            if tx.blocking_send(result).is_err() {
                break;
            }
        }
    });

    Ok(ReceiverStream::new(rx))
}
```

#### Alternative Implementation with Better Error Handling

```rust
/// More robust version with explicit error handling for spawn failures
pub async fn search_async_robust(
    query: &str,
    options: SearchOptions,
) -> Result<impl Stream<Item = Result<SearchResult>>> {
    let query = query.to_string();
    let (tx, rx) = mpsc::channel(100);

    let handle = tokio::task::spawn_blocking(move || {
        let iter = search_iter(&query, options)?;

        for result in iter {
            if tx.blocking_send(result).is_err() {
                // Receiver dropped, stop early
                break;
            }
        }

        Ok::<_, anyhow::Error>(())
    });

    // Spawn a task to check for panics in the blocking task
    let error_tx = tx.clone();
    tokio::spawn(async move {
        match handle.await {
            Ok(Ok(())) => {} // Success
            Ok(Err(e)) => {
                // Search error
                let _ = error_tx.send(Err(e)).await;
            }
            Err(e) => {
                // Panic in blocking task
                let _ = error_tx.send(Err(anyhow::anyhow!("Search task panicked: {}", e))).await;
            }
        }
    });

    Ok(ReceiverStream::new(rx))
}
```

### Example Usage

```rust
use rdump::{search_async, SearchOptions};
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

    while let Some(result) = stream.next().await {
        let result = result?;
        println!("{}", result.path.display());
    }

    Ok(())
}
```

### Testing

**Test Location:** `tests/async_api.rs`

**Test Cases:**
- Basic async streaming
- Early termination with `.take()`
- Drop stream stops producer
- Error propagation
- [Source: docs/architecture.md#test-strategy]

**Test Code:**
```rust
#[tokio::test]
async fn test_search_async_basic() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("test.rs"), "fn main() {}")?;
    fs::write(dir.path().join("lib.rs"), "pub fn add() {}")?;

    let mut stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    let mut count = 0;
    while let Some(result) = stream.next().await {
        let result = result?;
        assert!(result.path.extension().unwrap() == "rs");
        count += 1;
    }

    assert_eq!(count, 2);
    Ok(())
}

#[tokio::test]
async fn test_search_async_early_termination() -> Result<()> {
    let dir = tempdir()?;

    // Create many files
    for i in 0..50 {
        fs::write(dir.path().join(format!("file{}.rs", i)), "fn main() {}")?;
    }

    let stream = search_async("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    }).await?;

    // Take only first 5
    let first_five: Vec<_> = stream
        .take(5)
        .collect::<Vec<_>>()
        .await
        .into_iter()
        .collect::<Result<Vec<_>, _>>()?;

    assert_eq!(first_five.len(), 5);
    Ok(())
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
