# Story 1.24: Create Async Example Program

## Status
Ready for Review

## Story
**As a** library user in an async application,
**I want** a comprehensive async example program,
**so that** I can learn how to use the async API with tokio and understand async patterns.

## Acceptance Criteria

**Compilation:**
1. - [x] Example compiles without warnings
2. - [x] Example runs successfully with `--features async`
3. - [x] Works with `cargo run --features async --example async_search`

**Content:**
4. - [x] Shows basic async streaming
5. - [x] Shows early termination pattern
6. - [x] Shows concurrent stream processing
7. - [x] Shows integration with other async operations
8. - [x] Shows error handling in async context

**Code Quality:**
9. - [x] Includes helpful comments
10. - [x] Shows practical async patterns
11. - [x] Demonstrates tokio integration

**Output:**
12. - [x] Produces clear, informative output
13. - [x] Shows timing for async operations

## Tasks / Subtasks

- [x] Create example file `examples/async_search.rs` (AC: 1, 2, 3)
- [x] Implement example functions (AC: 4-8)
  - [x] `example_basic_async()` - basic streaming
  - [x] `example_early_termination()` - take N results
  - [x] `example_concurrent_streams()` - multiple searches
  - [x] `example_with_other_async()` - async file writes + delay
  - [x] `example_error_handling()` - async error patterns
- [x] Add helpful comments (AC: 9, 10, 11)
- [x] Ensure good output (AC: 12, 13)

## Dev Agent Record
- Agent Model Used: GPT-5 (Codex CLI)
- Debug Log References: N/A
- Completion Notes:
  - Added `examples/async_search.rs` (feature-gated) demonstrating async streaming, early termination, concurrent searches via `try_join!`, integration with other async work (tokio fs + delay), and error handling. Uses fixture root for deterministic output and prints timing/info.
  - Verified with `cargo run --features async --example async_search --offline`.
- File List:
  - rdump/examples/async_search.rs

## Dev Notes

### Location
- Example file: `examples/async_search.rs`
- [Source: docs/epics/library-api-epic.md - Story 24]

### Running the Example
```bash
cargo run --features async --example async_search
```

### Example Structure
```rust
use anyhow::Result;
use futures::StreamExt;
use rdump::{search_async, search_all_async, SearchOptions};

#[tokio::main]
async fn main() -> Result<()> {
    println!("rdump Async API Examples\n");

    example_basic_async().await?;
    example_early_termination().await?;
    example_concurrent_streams().await?;
    example_with_other_async().await?;
    example_error_handling().await?;

    println!("\nAll async examples completed!");
    Ok(())
}
```

### Key Patterns

**Basic Async Streaming:**
```rust
let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

while let Some(result) = stream.next().await {
    let result = result?;
    println!("{}", result.path.display());
}
```

**Concurrent Streams:**
```rust
let rust_search = search_async("ext:rs", options.clone());
let python_search = search_async("ext:py", options.clone());

let (rust_results, python_results) = tokio::join!(
    rust_search.await?.collect::<Vec<_>>(),
    python_search.await?.collect::<Vec<_>>()
);
```

**With Other Async Operations:**
```rust
let mut stream = search_async("ext:rs", options).await?;

while let Some(result) = stream.next().await {
    let result = result?;

    // Async file write
    tokio::fs::write(
        format!("output/{}.txt", result.path.file_name().unwrap().to_string_lossy()),
        &result.content
    ).await?;
}
```

### Complete Implementation

#### examples/async_search.rs

```rust
//! Async search example for rdump library
//!
//! Demonstrates async API patterns for tokio-based applications.
//!
//! Run with: cargo run --features async --example async_search

use anyhow::Result;
use futures::StreamExt;
use rdump::{search_async, search_all_async, SearchOptions, SearchResult};
use std::path::PathBuf;
use std::time::Instant;

#[tokio::main]
async fn main() -> Result<()> {
    println!("rdump Async API Examples\n");

    // Example 1: Basic async streaming
    example_basic_streaming().await?;

    // Example 2: Collect all results
    example_collect_all().await?;

    // Example 3: Early termination
    example_early_termination().await?;

    // Example 4: Concurrent searches
    example_concurrent_searches().await?;

    // Example 5: Processing with select
    example_with_timeout().await?;

    // Example 6: Aggregation
    example_aggregation().await?;

    println!("\nAll async examples completed!");
    Ok(())
}

/// Example 1: Basic async streaming
async fn example_basic_streaming() -> Result<()> {
    println!("=== Example 1: Basic Streaming ===");

    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

    let mut count = 0;
    while let Some(result) = stream.next().await {
        match result {
            Ok(r) => {
                count += 1;
                if count <= 3 {
                    println!("  {} ({} bytes)", r.path.display(), r.content.len());
                }
            }
            Err(e) => eprintln!("  Error: {}", e),
        }
    }

    if count > 3 {
        println!("  ... and {} more files", count - 3);
    }

    println!();
    Ok(())
}

/// Example 2: Collect all results at once
async fn example_collect_all() -> Result<()> {
    println!("=== Example 2: Collect All ===");

    let start = Instant::now();

    let results = search_all_async("ext:rs", SearchOptions::default()).await?;

    println!("Found {} files in {:?}", results.len(), start.elapsed());

    for result in results.iter().take(3) {
        println!("  - {}", result.path.display());
    }

    println!();
    Ok(())
}

/// Example 3: Early termination
async fn example_early_termination() -> Result<()> {
    println!("=== Example 3: Early Termination ===");

    let stream = search_async("ext:rs", SearchOptions::default()).await?;

    // Take only first 5 results
    let first_five: Vec<SearchResult> = stream
        .take(5)
        .filter_map(|r| async { r.ok() })
        .collect()
        .await;

    println!("Took first {} results:", first_five.len());
    for result in &first_five {
        println!("  - {}", result.path.display());
    }

    println!();
    Ok(())
}

/// Example 4: Run multiple searches concurrently
async fn example_concurrent_searches() -> Result<()> {
    println!("=== Example 4: Concurrent Searches ===");

    let start = Instant::now();

    // Clone options for each search
    let opts = SearchOptions::default();

    // Run searches concurrently
    let (rust_results, python_results, js_results) = tokio::join!(
        search_all_async("ext:rs", opts.clone()),
        search_all_async("ext:py", opts.clone()),
        search_all_async("ext:js", opts.clone()),
    );

    println!("Completed in {:?}", start.elapsed());
    println!("  Rust files:   {}", rust_results?.len());
    println!("  Python files: {}", python_results?.len());
    println!("  JS files:     {}", js_results?.len());

    println!();
    Ok(())
}

/// Example 5: Processing with timeout using select
async fn example_with_timeout() -> Result<()> {
    println!("=== Example 5: With Timeout ===");

    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;
    let timeout = tokio::time::sleep(std::time::Duration::from_millis(100));
    tokio::pin!(timeout);

    let mut count = 0;

    loop {
        tokio::select! {
            // Process next result
            result = stream.next() => {
                match result {
                    Some(Ok(_)) => count += 1,
                    Some(Err(e)) => eprintln!("Error: {}", e),
                    None => break,
                }
            }
            // Timeout
            _ = &mut timeout => {
                println!("Timeout! Processed {} files", count);
                break;
            }
        }
    }

    println!("Processed {} files before timeout/completion", count);
    println!();
    Ok(())
}

/// Example 6: Async aggregation with streaming
async fn example_aggregation() -> Result<()> {
    println!("=== Example 6: Aggregation ===");

    let stream = search_async("func:*", SearchOptions {
        presets: vec!["rust".to_string()],
        ..Default::default()
    }).await?;

    // Aggregate without collecting all results
    let mut file_count = 0;
    let mut total_functions = 0;
    let mut total_bytes = 0;

    tokio::pin!(stream);

    while let Some(result) = stream.next().await {
        if let Ok(r) = result {
            file_count += 1;
            total_functions += r.match_count();
            total_bytes += r.content.len();
        }
    }

    println!("Statistics:");
    println!("  Files:     {}", file_count);
    println!("  Functions: {}", total_functions);
    println!("  Bytes:     {} KB", total_bytes / 1024);

    println!();
    Ok(())
}

// =============================================================================
// Additional async patterns
// =============================================================================

/// Pattern: Fan-out search to multiple directories
#[allow(dead_code)]
async fn search_multiple_directories(dirs: Vec<PathBuf>) -> Result<Vec<SearchResult>> {
    let handles: Vec<_> = dirs
        .into_iter()
        .map(|dir| {
            tokio::spawn(async move {
                search_all_async("ext:rs", SearchOptions {
                    root: dir,
                    ..Default::default()
                }).await
            })
        })
        .collect();

    let mut all_results = Vec::new();
    for handle in handles {
        let results = handle.await??;
        all_results.extend(results);
    }

    Ok(all_results)
}

/// Pattern: Process results with bounded concurrency
#[allow(dead_code)]
async fn process_with_concurrency_limit() -> Result<()> {
    use futures::stream::StreamExt;

    let stream = search_async("ext:rs", SearchOptions::default()).await?;

    // Process up to 10 files concurrently
    stream
        .map(|result| async move {
            if let Ok(r) = result {
                process_file(&r).await;
            }
        })
        .buffer_unordered(10)  // Max 10 concurrent
        .collect::<Vec<_>>()
        .await;

    Ok(())
}

async fn process_file(result: &SearchResult) {
    // Simulate async processing
    tokio::time::sleep(std::time::Duration::from_millis(10)).await;
    println!("Processed: {}", result.path.display());
}

/// Pattern: Cancellable search with channel
#[allow(dead_code)]
async fn cancellable_search() -> Result<()> {
    use tokio::sync::oneshot;

    let (cancel_tx, cancel_rx) = oneshot::channel();
    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

    let search_task = tokio::spawn(async move {
        tokio::select! {
            _ = async {
                while let Some(result) = stream.next().await {
                    if let Ok(r) = result {
                        println!("{}", r.path.display());
                    }
                }
            } => {}
            _ = cancel_rx => {
                println!("Search cancelled!");
            }
        }
    });

    // Cancel after 50ms
    tokio::time::sleep(std::time::Duration::from_millis(50)).await;
    let _ = cancel_tx.send(());

    search_task.await?;
    Ok(())
}

/// Pattern: Stream to async writer
#[allow(dead_code)]
async fn stream_to_file() -> Result<()> {
    use tokio::io::AsyncWriteExt;

    let mut file = tokio::fs::File::create("results.txt").await?;
    let stream = search_async("ext:rs", SearchOptions::default()).await?;

    tokio::pin!(stream);

    while let Some(result) = stream.next().await {
        if let Ok(r) = result {
            file.write_all(format!("{}\n", r.path.display()).as_bytes()).await?;
        }
    }

    file.flush().await?;
    Ok(())
}
```

### Testing

**Test Location:** Example runs as integration test

**Verification:**
- `cargo run --features async --example async_search` completes
- Output is informative
- All async patterns work correctly
- [Source: docs/architecture.md#test-strategy]

**Running the Example:**
```bash
# Basic run
cargo run --features async --example async_search

# In a specific directory
cd /path/to/project
cargo run --features async --example async_search --manifest-path /path/to/rdump/Cargo.toml
```

**Why These Patterns?**

1. **Basic streaming**: Foundation for all async usage
2. **Collect all**: Simple case for small results
3. **Early termination**: Memory efficiency
4. **Concurrent**: Performance for multiple searches
5. **Timeout**: Integration with other async operations
6. **Aggregation**: Real-world analytics use case

**Dependencies for Examples:**

```toml
[dev-dependencies]
tokio = { version = "1", features = ["full"] }
futures = "0.3"
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
| 2025-11-21 | 0.2 | Added async example program and verified run | Dev Agent |
