# Story 1.18: Update README with Library Usage

## Status
Draft

## Story
**As a** potential library user,
**I want** a comprehensive library usage section in README.md,
**so that** I can quickly discover and get started with the library API from the project's main documentation.

## Acceptance Criteria

**Content:**
1. - [ ] Library usage section added after CLI usage
2. - [ ] Installation instructions included
3. - [ ] Quick start example works
4. - [ ] Streaming API example included
5. - [ ] SearchOptions fully explained
6. - [ ] Working with results demonstrated
7. - [ ] Error handling patterns shown
8. - [ ] Async support documented
9. - [ ] Query language reference table

**Quality:**
10. - [ ] All code examples compile and run
11. - [ ] Examples are concise but complete
12. - [ ] Consistent formatting with rest of README
13. - [ ] No broken links

**Verification:**
14. - [ ] Examples tested manually
15. - [ ] README renders correctly on GitHub
16. - [ ] Links to docs.rs work (after publish)

## Tasks / Subtasks

- [ ] Add Library Usage section to README.md (AC: 1)
- [ ] Add Installation subsection (AC: 2)
- [ ] Add Quick Start example (AC: 3)
- [ ] Add Streaming API example (AC: 4)
- [ ] Add Search Options documentation (AC: 5)
- [ ] Add Working with Results examples (AC: 6)
- [ ] Add Error Handling patterns (AC: 7)
- [ ] Add Async Support documentation (AC: 8)
- [ ] Add Query Language Reference (AC: 9)
- [ ] Test all code examples (AC: 10)
- [ ] Ensure consistent formatting (AC: 11, 12)
- [ ] Verify links work (AC: 13, 16)
- [ ] Test examples manually (AC: 14)
- [ ] Verify GitHub rendering (AC: 15)

## Dev Notes

### Location
- Primary file: `README.md`
- [Source: docs/epics/library-api-epic.md - Story 18]

### Why README Documentation Matters
- First thing users see on GitHub/crates.io
- Should provide immediate value without clicking further
- Complements but doesn't duplicate rustdoc

### Keeping Examples in Sync
Consider extracting examples to `examples/` directory and referencing them in README. This ensures examples are tested:
```bash
# Test README examples
cargo run --example readme_quickstart
cargo run --example readme_streaming
```

### Section Structure
1. Installation (`Cargo.toml` instructions)
2. Quick Start (basic search example)
3. Streaming API (memory-efficient example)
4. Search Options (all fields explained)
5. Working with Results (Match and SearchResult)
6. Error Handling (three strategies)
7. Async Support (feature flag and example)
8. Query Language Reference (table of predicates)

### Complete Implementation

Add the following section to README.md after the CLI usage section:

```markdown
## Library Usage

rdump can be used as a Rust library in your own projects.

### Installation

Add rdump to your `Cargo.toml`:

```toml
[dependencies]
rdump = "0.1"
```

### Quick Start

```rust
use rdump::{search, SearchOptions};

fn main() -> anyhow::Result<()> {
    // Find all Rust files with a main function
    let results = search("ext:rs & func:main", SearchOptions::default())?;

    println!("Found {} files", results.len());

    for result in &results {
        println!("{}: {} matches",
            result.path.display(),
            result.matches.len()
        );
    }

    Ok(())
}
```

### Streaming API (Memory-Efficient)

For large codebases, use `search_iter()` to process results lazily:

```rust
use rdump::{search_iter, SearchOptions};

fn main() -> anyhow::Result<()> {
    let iter = search_iter("ext:rs", SearchOptions::default())?;

    println!("Processing {} files...", iter.remaining());

    // Only first 10 files are loaded from disk
    for result in iter.take(10) {
        let result = result?;
        println!("{} ({} bytes)",
            result.path.display(),
            result.content.len()
        );
    }

    Ok(())
}
```

### Search Options

Customize your search with `SearchOptions`:

```rust
use rdump::{search, SearchOptions};
use std::path::PathBuf;

let options = SearchOptions {
    // Search in a specific directory
    root: PathBuf::from("./src"),

    // Use presets to filter by language
    presets: vec!["rust".to_string()],

    // Include hidden files
    hidden: true,

    // Ignore .gitignore rules
    no_ignore: false,

    // Limit directory depth
    max_depth: Some(5),

    // SQL dialect for .sql files
    sql_dialect: None,
};

let results = search("func:new", options)?;
```

### Working with Results

```rust
use rdump::{search, SearchOptions};

let results = search("func:main", SearchOptions::default())?;

for result in &results {
    // Check if whole file matched (e.g., ext:rs)
    if result.is_whole_file_match() {
        println!("{}: whole file match", result.path.display());
        continue;
    }

    // Work with specific matches
    for m in &result.matches {
        println!("{}:{}:{}",
            result.path.display(),
            m.start_line,      // 1-indexed line number
            m.first_line()     // First line of matched text
        );

        // Multi-line matches
        if m.is_multiline() {
            println!("  Spans {} lines", m.line_count());
        }
    }

    // Aggregate statistics
    println!("  {} matches, {} lines total",
        result.match_count(),
        result.total_lines_matched()
    );
}
```

### Error Handling

```rust
use rdump::{search_iter, SearchOptions};

// Strategy 1: Fail on first error
let results = search_iter("ext:rs", SearchOptions::default())?
    .collect::<Result<Vec<_>, _>>()?;

// Strategy 2: Skip errors and continue
let results: Vec<_> = search_iter("ext:rs", SearchOptions::default())?
    .filter_map(Result::ok)
    .collect();

// Strategy 3: Collect errors separately
let mut successes = Vec::new();
let mut errors = Vec::new();

for result in search_iter("ext:rs", SearchOptions::default())? {
    match result {
        Ok(r) => successes.push(r),
        Err(e) => errors.push(e),
    }
}
```

### Async Support

Enable the `async` feature for tokio-compatible async functions:

```toml
[dependencies]
rdump = { version = "0.1", features = ["async"] }
```

```rust
use rdump::{search_async, SearchOptions};
use futures::StreamExt;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut stream = search_async("ext:rs", SearchOptions::default()).await?;

    while let Some(result) = stream.next().await {
        let result = result?;
        println!("{}", result.path.display());
    }

    Ok(())
}
```

### Query Language Reference

rdump uses RQL (rdump Query Language):

| Predicate | Description | Example |
|-----------|-------------|---------|
| `ext:` | File extension | `ext:rs`, `ext:py` |
| `lang:` | Programming language | `lang:rust`, `lang:python` |
| `func:` | Function name | `func:main`, `func:new` |
| `class:` | Class/struct name | `class:User` |
| `content:` | Text content | `content:TODO` |
| `path:` | Path pattern | `path:src/` |

**Operators:**
- `&` or ` ` (space) - AND
- `|` - OR
- `!` - NOT
- `()` - Grouping

**Examples:**
```
ext:rs & func:main           # Rust files with main function
ext:py | ext:js              # Python or JavaScript files
ext:rs & !path:test          # Rust files not in test directories
lang:rust & (func:new | func:default)  # Rust files with new or default
```
```

### Testing

**Test Location:** Manual verification

**Verification:**
- All code examples compile
- Examples are tested manually
- README renders on GitHub
- Links work after publish
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
