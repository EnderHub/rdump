# Story 1.14: Write Advanced Integration Tests

## Status
Draft

## Story
**As a** library maintainer,
**I want** integration tests for advanced features and edge cases,
**so that** streaming behavior, SearchOptions fields, and error recovery are thoroughly verified.

## Acceptance Criteria

**Streaming Tests:**
1. - [ ] `test_search_iter_basic` - passes
2. - [ ] `test_search_iter_early_termination` - passes
3. - [ ] `test_search_iter_size_hint` - passes
4. - [ ] `test_search_iter_remaining` - passes
5. - [ ] `test_search_iter_skip_errors` - passes

**SearchOptions Tests:**
6. - [ ] `test_max_depth_option` - passes
7. - [ ] `test_hidden_files_option` - passes
8. - [ ] `test_no_ignore_option` - passes
9. - [ ] `test_presets_option` - passes
10. - [ ] `test_multiple_presets` - passes
11. - [ ] `test_custom_root` - passes

**Edge Case Tests:**
12. - [ ] `test_unicode_in_file_content` - passes
13. - [ ] `test_unicode_in_file_path` - passes
14. - [ ] `test_empty_file` - passes
15. - [ ] `test_very_long_lines` - passes
16. - [ ] `test_symlinks_not_followed_by_default` - passes
17. - [ ] `test_binary_file_detection` - passes
18. - [ ] `test_results_can_be_accessed_after_tempdir_dropped` - passes

## Tasks / Subtasks

- [ ] Add streaming iterator tests to `tests/library_api.rs` (AC: 1-5)
  - [ ] Basic streaming
  - [ ] Early termination with `.take()`
  - [ ] Size hint accuracy
  - [ ] Remaining count
  - [ ] Skip errors pattern
- [ ] Add SearchOptions field tests (AC: 6-11)
  - [ ] max_depth with nested directories
  - [ ] hidden files inclusion
  - [ ] .gitignore handling
  - [ ] Preset filtering
  - [ ] Multiple presets
  - [ ] Custom root directory
- [ ] Add edge case tests (AC: 12-18)
  - [ ] Unicode in content and paths
  - [ ] Empty files
  - [ ] Very long lines
  - [ ] Symlink behavior
  - [ ] Binary file detection
  - [ ] Result ownership after tempdir drop

## Dev Notes

### Location
- Test file: `tests/library_api.rs` (continue in same file)
- [Source: docs/epics/library-api-epic.md - Story 14]

### Running Tests
```bash
cargo test --test library_api
```

### Key Test Scenarios

**Streaming Early Termination:**
```rust
let iter = search_iter("ext:rs", options)?;
let first_five: Vec<_> = iter.take(5).collect::<Result<Vec<_>, _>>()?;
// Only 5 files were read from disk
```

**Max Depth Test Structure:**
```
root/
  level1.rs           (depth 1)
  sub/
    level2.rs         (depth 2)
    sub/
      level3.rs       (depth 3)
```

**Results Ownership:**
Results should own their data - they must remain valid after the tempdir is dropped.

### Complete Implementation

```rust
// =============================================================================
// Streaming Iterator Tests
// =============================================================================

#[test]
fn test_search_iter_basic() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let results: Vec<_> = iter.collect::<Result<Vec<_>, _>>()?;

    assert_eq!(results.len(), 3);

    Ok(())
}

#[test]
fn test_search_iter_early_termination() -> Result<()> {
    let dir = tempdir()?;

    // Create 100 files
    for i in 0..100 {
        fs::write(dir.path().join(format!("file{}.rs", i)), "fn main() {}")?;
    }

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Only take first 5 - should not process all 100
    let first_five: Vec<_> = iter.take(5).collect::<Result<Vec<_>, _>>()?;

    assert_eq!(first_five.len(), 5);

    // Note: This test verifies the API works; actual early termination
    // of file reads happens automatically due to lazy loading

    Ok(())
}

#[test]
fn test_search_iter_size_hint() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    let (lower, upper) = iter.size_hint();

    // Should know exact size
    assert_eq!(lower, 3);
    assert_eq!(upper, Some(3));

    Ok(())
}

#[test]
fn test_search_iter_remaining() -> Result<()> {
    let dir = create_rust_fixtures()?;

    let mut iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(iter.remaining(), 3);

    iter.next();
    assert_eq!(iter.remaining(), 2);

    iter.next();
    assert_eq!(iter.remaining(), 1);

    iter.next();
    assert_eq!(iter.remaining(), 0);

    Ok(())
}

#[test]
fn test_search_iter_skip_errors() -> Result<()> {
    let dir = tempdir()?;
    fs::write(dir.path().join("good.rs"), "fn main() {}")?;

    let iter = search_iter("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Demonstrates how to skip errors and continue
    let results: Vec<_> = iter.filter_map(Result::ok).collect();

    assert_eq!(results.len(), 1);

    Ok(())
}

// =============================================================================
// SearchOptions Field Tests
// =============================================================================

#[test]
fn test_max_depth_option() -> Result<()> {
    let dir = tempdir()?;

    // Create nested structure
    // root/
    //   level1.rs           (depth 1)
    //   sub/
    //     level2.rs         (depth 2)
    //     sub/
    //       level3.rs       (depth 3)

    fs::write(dir.path().join("level1.rs"), "fn main() {}")?;

    let sub = dir.path().join("sub");
    fs::create_dir(&sub)?;
    fs::write(sub.join("level2.rs"), "fn main() {}")?;

    let subsub = sub.join("sub");
    fs::create_dir(&subsub)?;
    fs::write(subsub.join("level3.rs"), "fn main() {}")?;

    // Without depth limit - find all 3
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;
    assert_eq!(results.len(), 3);

    // With max_depth: 1 - find only level1.rs
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        max_depth: Some(1),
        ..Default::default()
    })?;
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "level1.rs");

    // With max_depth: 2 - find level1.rs and level2.rs
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        max_depth: Some(2),
        ..Default::default()
    })?;
    assert_eq!(results.len(), 2);

    Ok(())
}

#[test]
fn test_hidden_files_option() -> Result<()> {
    let dir = tempdir()?;

    fs::write(dir.path().join("visible.rs"), "fn main() {}")?;
    fs::write(dir.path().join(".hidden.rs"), "fn main() {}")?;

    // Without hidden: true - only visible file
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        hidden: false,
        ..Default::default()
    })?;
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "visible.rs");

    // With hidden: true - both files
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        hidden: true,
        ..Default::default()
    })?;
    assert_eq!(results.len(), 2);

    Ok(())
}

#[test]
fn test_no_ignore_option() -> Result<()> {
    let dir = tempdir()?;

    // Create a .gitignore
    fs::write(dir.path().join(".gitignore"), "ignored.rs\n")?;
    fs::write(dir.path().join("included.rs"), "fn main() {}")?;
    fs::write(dir.path().join("ignored.rs"), "fn main() {}")?;

    // With no_ignore: false (default) - respect .gitignore
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        no_ignore: false,
        ..Default::default()
    })?;
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "included.rs");

    // With no_ignore: true - include ignored files
    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        no_ignore: true,
        ..Default::default()
    })?;
    assert_eq!(results.len(), 2);

    Ok(())
}

#[test]
fn test_presets_option() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Use rust preset - should only find .rs files
    let results = search("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string()],
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].path.extension().unwrap() == "rs");

    Ok(())
}

#[test]
fn test_multiple_presets() -> Result<()> {
    let dir = create_multi_lang_fixtures()?;

    // Use multiple presets
    let results = search("", SearchOptions {
        root: dir.path().to_path_buf(),
        presets: vec!["rust".to_string(), "python".to_string()],
        ..Default::default()
    })?;

    // Should find .rs and .py files
    assert_eq!(results.len(), 2);

    let extensions: Vec<_> = results
        .iter()
        .map(|r| r.path.extension().unwrap().to_str().unwrap())
        .collect();

    assert!(extensions.contains(&"rs"));
    assert!(extensions.contains(&"py"));

    Ok(())
}

#[test]
fn test_custom_root() -> Result<()> {
    let dir = create_rust_fixtures()?;

    // Search only in the src subdirectory
    let results = search("ext:rs", SearchOptions {
        root: dir.path().join("src"),
        ..Default::default()
    })?;

    // Should only find utils.rs
    assert_eq!(results.len(), 1);
    assert!(results[0].path.file_name().unwrap() == "utils.rs");

    Ok(())
}

// =============================================================================
// Edge Case Tests
// =============================================================================

#[test]
fn test_unicode_in_file_content() -> Result<()> {
    let dir = tempdir()?;

    // File with Unicode content
    fs::write(
        dir.path().join("unicode.rs"),
        r#"fn ä½ å¥½() -> &'static str {
    "ã“ã‚“ã«ã¡ã¯ ðŸ¦€"
}
"#,
    )?;

    let results = search("func:ä½ å¥½", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].matches[0].text.contains("ä½ å¥½"));

    Ok(())
}

#[test]
fn test_unicode_in_file_path() -> Result<()> {
    let dir = tempdir()?;

    // Create file with Unicode in path
    let path = dir.path().join("cÃ³digo.rs");
    fs::write(&path, "fn main() {}")?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].path.to_string_lossy().contains("cÃ³digo"));

    Ok(())
}

#[test]
fn test_empty_file() -> Result<()> {
    let dir = tempdir()?;

    fs::write(dir.path().join("empty.rs"), "")?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].content.is_empty());

    Ok(())
}

#[test]
fn test_very_long_lines() -> Result<()> {
    let dir = tempdir()?;

    // Create file with very long line
    let long_string = "x".repeat(10000);
    fs::write(
        dir.path().join("long.rs"),
        format!("fn main() {{ let s = \"{}\"; }}", long_string),
    )?;

    let results = search("func:main", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    assert_eq!(results.len(), 1);
    assert!(results[0].matches[0].text.len() > 10000);

    Ok(())
}

#[test]
fn test_symlinks_not_followed_by_default() -> Result<()> {
    // Skip on Windows where symlinks require special permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::symlink;

        let dir = tempdir()?;
        let target_dir = tempdir()?;

        // Create file in target directory
        fs::write(target_dir.path().join("target.rs"), "fn main() {}")?;

        // Create symlink in search directory
        symlink(target_dir.path(), dir.path().join("link"))?;

        // By default, symlinks should not be followed
        let results = search("ext:rs", SearchOptions {
            root: dir.path().to_path_buf(),
            ..Default::default()
        })?;

        // Behavior depends on walker configuration
        // This test documents the current behavior
        println!("Symlink test found {} results", results.len());
    }

    Ok(())
}

#[test]
fn test_binary_file_detection() -> Result<()> {
    let dir = tempdir()?;

    // Create a text file
    fs::write(dir.path().join("text.rs"), "fn main() {}")?;

    // Create a binary file (with null bytes)
    let mut binary_content = vec![0u8; 100];
    binary_content[0] = b'f';
    binary_content[1] = b'n';
    fs::write(dir.path().join("binary.dat"), binary_content)?;

    let results = search("ext:rs", SearchOptions {
        root: dir.path().to_path_buf(),
        ..Default::default()
    })?;

    // Should only find text file
    assert_eq!(results.len(), 1);

    Ok(())
}

// =============================================================================
// Concurrent Access Tests
// =============================================================================

#[test]
fn test_results_can_be_accessed_after_tempdir_dropped() {
    // This is important: results should own their data
    let results = {
        let dir = tempdir().unwrap();
        fs::write(dir.path().join("test.rs"), "fn main() {}").unwrap();

        search("ext:rs", SearchOptions {
            root: dir.path().to_path_buf(),
            ..Default::default()
        })
        .unwrap()
        // dir is dropped here
    };

    // Results should still be valid
    assert_eq!(results.len(), 1);
    assert!(results[0].content.contains("fn main"));
}
```

### Testing

**Test Location:** `tests/library_api.rs`

**Test Categories:**
- Streaming behavior
- SearchOptions fields
- Edge cases (Unicode, empty files, symlinks)
- [Source: docs/architecture.md#test-strategy]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-11-21 | 0.1 | Initial draft | SM Agent |
